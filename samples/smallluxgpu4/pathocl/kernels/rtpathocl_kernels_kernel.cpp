#include <string>
namespace slg { namespace ocl {
std::string KernelSource_rtpathocl_kernels = 
"#line 2 \"rtpatchocl_kernels.cl\"\n"
"\n"
"/***************************************************************************\n"
" *   Copyright (C) 1998-2010 by authors (see AUTHORS.txt )                 *\n"
" *                                                                         *\n"
" *   This file is part of LuxRays.                                         *\n"
" *                                                                         *\n"
" *   LuxRays is free software; you can redistribute it and/or modify       *\n"
" *   it under the terms of the GNU General Public License as published by  *\n"
" *   the Free Software Foundation; either version 3 of the License, or     *\n"
" *   (at your option) any later version.                                   *\n"
" *                                                                         *\n"
" *   LuxRays is distributed in the hope that it will be useful,            *\n"
" *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *\n"
" *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *\n"
" *   GNU General Public License for more details.                          *\n"
" *                                                                         *\n"
" *   You should have received a copy of the GNU General Public License     *\n"
" *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *\n"
" *                                                                         *\n"
" *   LuxRays website: http://www.luxrender.net                             *\n"
" ***************************************************************************/\n"
"\n"
"#define FRAMEBUFFER_WIDTH (PARAM_IMAGE_WIDTH + 2)\n"
"#define FRAMEBUFFER_HEIGHT (PARAM_IMAGE_HEIGHT + 2)\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// InitDisplayFrameBuffer Kernel\n"
"//------------------------------------------------------------------------------\n"
"\n"
"__kernel __attribute__((work_group_size_hint(64, 1, 1))) void InitDisplayFrameBuffer(\n"
"		__global Pixel *frameBuffer) {\n"
"	const size_t gid = get_global_id(0);\n"
"	if (gid >= FRAMEBUFFER_WIDTH * FRAMEBUFFER_HEIGHT)\n"
"		return;\n"
"\n"
"	VSTORE4F(0.f, &frameBuffer[gid].c.r);\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// MergeFrameBuffer Kernel\n"
"//------------------------------------------------------------------------------\n"
"\n"
"__kernel __attribute__((work_group_size_hint(64, 1, 1))) void MergeFrameBuffer(\n"
"		__global Pixel *srcFrameBuffer,\n"
"		__global Pixel *dstFrameBuffer) {\n"
"	const size_t gid = get_global_id(0);\n"
"	if (gid >= FRAMEBUFFER_WIDTH * FRAMEBUFFER_HEIGHT)\n"
"		return;\n"
"\n"
"	const float4 srcRGBC = VLOAD4F(&srcFrameBuffer[gid].c.r);\n"
"	const float4 dstRGBC = VLOAD4F(&dstFrameBuffer[gid].c.r);\n"
"	VSTORE4F(srcRGBC + dstRGBC, &dstFrameBuffer[gid].c.r);\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Image filtering kernels\n"
"//------------------------------------------------------------------------------\n"
"\n"
"void ApplyBlurFilterXR1(\n"
"		__global Pixel *src,\n"
"		__global Pixel *dst,\n"
"		const float aF,\n"
"		const float bF,\n"
"		const float cF\n"
"		) {\n"
"	// Do left edge\n"
"	Pixel a;\n"
"	Pixel b = src[0];\n"
"	Pixel c = src[1];\n"
"	float invACount, invBCount, invCCount;\n"
"\n"
"	const float leftTotF = bF + cF;\n"
"	const float bLeftK = bF / leftTotF;\n"
"	const float cLeftK = cF / leftTotF;\n"
"	invBCount = 1.f / b.count;\n"
"	invCCount = 1.f / c.count;\n"
"	dst[0].c.r = bLeftK * b.c.r * invBCount + cLeftK * c.c.r * invCCount;\n"
"	dst[0].c.g = bLeftK * b.c.g * invBCount + cLeftK * c.c.g * invCCount;\n"
"	dst[0].c.b = bLeftK * b.c.b * invBCount + cLeftK * c.c.b * invCCount;\n"
"\n"
"    // Main loop\n"
"	const float totF = aF + bF + cF;\n"
"	const float aK = aF / totF;\n"
"	const float bK = bF / totF;\n"
"	const float cK = cF / totF;\n"
"\n"
"	for (unsigned int x = 1; x < FRAMEBUFFER_WIDTH - 1; ++x) {\n"
"		a = b;\n"
"		invACount = invBCount;\n"
"		b = c;\n"
"		invBCount = invCCount;\n"
"		c = src[x + 1];\n"
"		invCCount = 1.f / c.count;\n"
"\n"
"		dst[x].c.r = aK * a.c.r * invACount + bK * b.c.r * invBCount + cK * c.c.r * invCCount;\n"
"		dst[x].c.g = aK * a.c.g * invACount + bK * b.c.g * invBCount + cK * c.c.g * invCCount;\n"
"		dst[x].c.b = aK * a.c.b * invACount + bK * b.c.b * invBCount + cK * c.c.b * invCCount;\n"
"    }\n"
"\n"
"    // Do right edge\n"
"	const float rightTotF = aF + bF;\n"
"	const float aRightK = aF / rightTotF;\n"
"	const float bRightK = bF / rightTotF;\n"
"	a = b;\n"
"	b = c;\n"
"	dst[FRAMEBUFFER_WIDTH - 1].c.r = aRightK * a.c.r + bRightK * b.c.r;\n"
"	dst[FRAMEBUFFER_WIDTH - 1].c.g = aRightK * a.c.g + bRightK * b.c.g;\n"
"	dst[FRAMEBUFFER_WIDTH - 1].c.b = aRightK * a.c.b + bRightK * b.c.b;\n"
"\n"
"}\n"
"\n"
"void ApplyBlurFilterYR1(\n"
"		__global Pixel *src,\n"
"		__global Pixel *dst,\n"
"		const float aF,\n"
"		const float bF,\n"
"		const float cF\n"
"		) {\n"
"	// Do left edge\n"
"	Pixel a;\n"
"	Pixel b = src[0];\n"
"	Pixel c = src[FRAMEBUFFER_WIDTH];\n"
"	float invACount, invBCount, invCCount;\n"
"\n"
"	const float leftTotF = bF + cF;\n"
"	const float bLeftK = bF / leftTotF;\n"
"	const float cLeftK = cF / leftTotF;\n"
"	invBCount = 1.f / b.count;\n"
"	invCCount = 1.f / c.count;\n"
"	dst[0].c.r = bLeftK * b.c.r * invBCount + cLeftK * c.c.r * invCCount;\n"
"	dst[0].c.g = bLeftK * b.c.g * invBCount + cLeftK * c.c.g * invCCount;\n"
"	dst[0].c.b = bLeftK * b.c.b * invBCount + cLeftK * c.c.b * invCCount;\n"
"\n"
"    // Main loop\n"
"	const float totF = aF + bF + cF;\n"
"	const float aK = aF / totF;\n"
"	const float bK = bF / totF;\n"
"	const float cK = cF / totF;\n"
"\n"
"    for (unsigned int y = 1; y < FRAMEBUFFER_HEIGHT - 1; ++y) {\n"
"		const unsigned index = y * FRAMEBUFFER_WIDTH;\n"
"\n"
"		a = b;\n"
"		invACount = invBCount;\n"
"		b = c;\n"
"		invBCount = invCCount;\n"
"		c = src[index + FRAMEBUFFER_WIDTH];\n"
"		invCCount = 1.f / c.count;\n"
"\n"
"		dst[index].c.r = aK * a.c.r * invACount + bK * b.c.r * invBCount + cK * c.c.r * invCCount;\n"
"		dst[index].c.g = aK * a.c.g * invACount + bK * b.c.g * invBCount + cK * c.c.g * invCCount;\n"
"		dst[index].c.b = aK * a.c.b * invACount + bK * b.c.b * invBCount + cK * c.c.b * invCCount;\n"
"    }\n"
"\n"
"    // Do right edge\n"
"	const float rightTotF = aF + bF;\n"
"	const float aRightK = aF / rightTotF;\n"
"	const float bRightK = bF / rightTotF;\n"
"	a = b;\n"
"	b = c;\n"
"	dst[(FRAMEBUFFER_HEIGHT - 1) * FRAMEBUFFER_WIDTH].c.r = aRightK * a.c.r + bRightK * b.c.r;\n"
"	dst[(FRAMEBUFFER_HEIGHT - 1) * FRAMEBUFFER_WIDTH].c.g = aRightK * a.c.g + bRightK * b.c.g;\n"
"	dst[(FRAMEBUFFER_HEIGHT - 1) * FRAMEBUFFER_WIDTH].c.b = aRightK * a.c.b + bRightK * b.c.b;\n"
"}\n"
"\n"
"__kernel __attribute__((work_group_size_hint(64, 1, 1))) void ApplyBlurLightFilterXR1(\n"
"		__global Pixel *src,\n"
"		__global Pixel *dst\n"
"		) {\n"
"	const size_t gid = get_global_id(0);\n"
"	if (gid >= FRAMEBUFFER_HEIGHT)\n"
"		return;\n"
"\n"
"	src += gid * FRAMEBUFFER_WIDTH;\n"
"	dst += gid * FRAMEBUFFER_WIDTH;\n"
"\n"
"	const float aF = .15f;\n"
"	const float bF = 1.f;\n"
"	const float cF = .15f;\n"
"\n"
"	ApplyBlurFilterXR1(src, dst, aF, bF, cF);\n"
"}\n"
"\n"
"__kernel __attribute__((work_group_size_hint(64, 1, 1))) void ApplyBlurLightFilterYR1(\n"
"		__global Pixel *src,\n"
"		__global Pixel *dst\n"
"		) {\n"
"	const size_t gid = get_global_id(0);\n"
"	if (gid >= FRAMEBUFFER_WIDTH)\n"
"		return;\n"
"\n"
"	src += gid;\n"
"	dst += gid;\n"
"\n"
"	const float aF = .15f;\n"
"	const float bF = 1.f;\n"
"	const float cF = .15f;\n"
"\n"
"	ApplyBlurFilterYR1(src, dst, aF, bF, cF);\n"
"}\n"
"\n"
"__kernel __attribute__((work_group_size_hint(64, 1, 1))) void ApplyBlurHeavyFilterXR1(\n"
"		__global Pixel *src,\n"
"		__global Pixel *dst\n"
"		) {\n"
"	const size_t gid = get_global_id(0);\n"
"	if (gid >= FRAMEBUFFER_HEIGHT)\n"
"		return;\n"
"\n"
"	src += gid * FRAMEBUFFER_WIDTH;\n"
"	dst += gid * FRAMEBUFFER_WIDTH;\n"
"\n"
"	const float aF = .35f;\n"
"	const float bF = 1.f;\n"
"	const float cF = .35f;\n"
"\n"
"	ApplyBlurFilterXR1(src, dst, aF, bF, cF);\n"
"}\n"
"\n"
"__kernel __attribute__((work_group_size_hint(64, 1, 1))) void ApplyBlurHeavyFilterYR1(\n"
"		__global Pixel *src,\n"
"		__global Pixel *dst\n"
"		) {\n"
"	const size_t gid = get_global_id(0);\n"
"	if (gid >= FRAMEBUFFER_WIDTH)\n"
"		return;\n"
"\n"
"	src += gid;\n"
"	dst += gid;\n"
"\n"
"	const float aF = .35f;\n"
"	const float bF = 1.f;\n"
"	const float cF = .35f;\n"
"\n"
"	ApplyBlurFilterYR1(src, dst, aF, bF, cF);\n"
"}\n"
"\n"
"__kernel __attribute__((work_group_size_hint(64, 1, 1))) void ApplyBoxFilterXR1(\n"
"		__global Pixel *src,\n"
"		__global Pixel *dst\n"
"		) {\n"
"	const size_t gid = get_global_id(0);\n"
"	if (gid >= FRAMEBUFFER_HEIGHT)\n"
"		return;\n"
"\n"
"	src += gid * FRAMEBUFFER_WIDTH;\n"
"	dst += gid * FRAMEBUFFER_WIDTH;\n"
"\n"
"	const float aF = .35f;\n"
"	const float bF = 1.f;\n"
"	const float cF = .35f;\n"
"\n"
"	ApplyBlurFilterXR1(src, dst, aF, bF, cF);\n"
"}\n"
"\n"
"__kernel __attribute__((work_group_size_hint(64, 1, 1))) void ApplyBoxFilterYR1(\n"
"		__global Pixel *src,\n"
"		__global Pixel *dst\n"
"		) {\n"
"	const size_t gid = get_global_id(0);\n"
"	if (gid >= FRAMEBUFFER_WIDTH)\n"
"		return;\n"
"\n"
"	src += gid;\n"
"	dst += gid;\n"
"\n"
"	const float aF = 1.f / 3.f;\n"
"	const float bF = 1.f / 3.f;\n"
"	const float cF = 1.f / 3.f;\n"
"\n"
"	ApplyBlurFilterYR1(src, dst, aF, bF, cF);\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Linear Tone Map Kernel\n"
"//------------------------------------------------------------------------------\n"
"\n"
"__kernel void ToneMapLinear(\n"
"		__global Pixel *src,\n"
"		__global Pixel *dst) {\n"
"	const int gid = get_global_id(0);\n"
"	if (gid >= FRAMEBUFFER_WIDTH * FRAMEBUFFER_HEIGHT)\n"
"		return;\n"
"\n"
"	const float4 k = (float4)(PARAM_TONEMAP_LINEAR_SCALE, PARAM_TONEMAP_LINEAR_SCALE, PARAM_TONEMAP_LINEAR_SCALE, 1.f);\n"
"	const float4 sp = VLOAD4F(&src[gid].c.r);\n"
"\n"
"	VSTORE4F(k * sp, &dst[gid].c.r);\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// UpdateScreenBuffer Kernel\n"
"//------------------------------------------------------------------------------\n"
"\n"
"//uint Radiance2PixelUInt(const float x) {\n"
"//	return (uint)(pow(clamp(x, 0.f, 1.f), 1.f / PARAM_GAMMA) * 255.f + .5f);\n"
"//}\n"
"\n"
"float Radiance2PixelFloat(const float x) {\n"
"	return pow(clamp(x, 0.f, 1.f), 1.f / PARAM_GAMMA);\n"
"}\n"
"\n"
"__kernel void UpdateScreenBuffer(\n"
"		__global Pixel *frameBuffer,\n"
"		__global Spectrum *pbo) {\n"
"	const int gid = get_global_id(0);\n"
"	const int x = gid % FRAMEBUFFER_WIDTH - 2;\n"
"	const int y = gid / FRAMEBUFFER_WIDTH - 2;\n"
"	if ((x < 0) || (y < 0) || (x >= PARAM_IMAGE_WIDTH) || (y >= PARAM_IMAGE_HEIGHT))\n"
"		return;\n"
"\n"
"	__global Pixel *sp = &frameBuffer[gid];\n"
"\n"
"	Spectrum rgb;\n"
"	const float count = sp->count;\n"
"	if (count > 0.f) {\n"
"		const float invCount = 1.f / count;\n"
"		rgb.r = Radiance2PixelFloat(sp->c.r * invCount);\n"
"		rgb.g = Radiance2PixelFloat(sp->c.g * invCount);\n"
"		rgb.b = Radiance2PixelFloat(sp->c.b * invCount);\n"
"	} else {\n"
"		rgb.r = 0.f;\n"
"		rgb.g = 0.f;\n"
"		rgb.b = 0.f;\n"
"	}\n"
"\n"
"	pbo[(x + y * PARAM_IMAGE_WIDTH)] = rgb;\n"
"}\n"
; } }
