#include <string>
namespace luxrays { namespace ocl {
std::string KernelSource_mbvh = 
"#line 2 \"mbvh_kernel.cl\"\n"
"\n"
"/***************************************************************************\n"
" *   Copyright (C) 1998-2013 by authors (see AUTHORS.txt)                  *\n"
" *                                                                         *\n"
" *   This file is part of LuxRays.                                         *\n"
" *                                                                         *\n"
" *   LuxRays is free software; you can redistribute it and/or modify       *\n"
" *   it under the terms of the GNU General Public License as published by  *\n"
" *   the Free Software Foundation; either version 3 of the License, or     *\n"
" *   (at your option) any later version.                                   *\n"
" *                                                                         *\n"
" *   LuxRays is distributed in the hope that it will be useful,            *\n"
" *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *\n"
" *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *\n"
" *   GNU General Public License for more details.                          *\n"
" *                                                                         *\n"
" *   You should have received a copy of the GNU General Public License     *\n"
" *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *\n"
" *                                                                         *\n"
" *   LuxRays website: http://www.luxrender.net                             *\n"
" ***************************************************************************/\n"
"\n"
"\n"
"typedef struct {\n"
"	union {\n"
"		struct {\n"
"			// I can not use BBox here because objects with a constructor are not\n"
"			// allowed inside an union.\n"
"			float bboxMin[3];\n"
"			float bboxMax[3];\n"
"		} bvhNode;\n"
"		struct {\n"
"			uint v[3];\n"
"			uint triangleIndex;\n"
"		} triangleLeaf;\n"
"		struct {\n"
"			uint leafIndex;\n"
"			uint transformIndex;\n"
"			uint triangleOffsetIndex;\n"
"		} bvhLeaf; // Used by MBVH\n"
"	};\n"
"	// Most significant bit is used to mark leafs\n"
"	uint nodeData;\n"
"} BVHAccelArrayNode;\n"
"\n"
"#define BVHNodeData_IsLeaf(nodeData) ((nodeData) & 0x80000000u)\n"
"#define BVHNodeData_GetSkipIndex(nodeData) ((nodeData) & 0x7fffffffu)\n"
"#if (MBVH_NODES_PAGE_COUNT > 1)\n"
"#define BVHNodeData_GetPageIndex(nodeData) (((nodeData) & 0x70000000u) >> 28)\n"
"#define BVHNodeData_GetNodeIndex(nodeData) ((nodeData) & 0x0fffffffu)\n"
"#endif\n"
"\n"
"void TransformP(Point *ptrans, const Point *p, __global Matrix4x4 *m) {\n"
"    const float x = p->x;\n"
"    const float y = p->y;\n"
"    const float z = p->z;\n"
"\n"
"	ptrans->x = m->m[0][0] * x + m->m[0][1] * y + m->m[0][2] * z + m->m[0][3];\n"
"	ptrans->y = m->m[1][0] * x + m->m[1][1] * y + m->m[1][2] * z + m->m[1][3];\n"
"	ptrans->z = m->m[2][0] * x + m->m[2][1] * y + m->m[2][2] * z + m->m[2][3];\n"
"	const float w = m->m[3][0] * x + m->m[3][1] * y + m->m[3][2] * z + m->m[3][3];\n"
"\n"
"    ptrans->x /= w;\n"
"    ptrans->y /= w;\n"
"    ptrans->z /= w;\n"
"}\n"
"\n"
"void TransformV(Vector *ptrans, const Vector *p, __global Matrix4x4 *m) {\n"
"    const float x = p->x;\n"
"    const float y = p->y;\n"
"    const float z = p->z;\n"
"\n"
"	ptrans->x = m->m[0][0] * x + m->m[0][1] * y + m->m[0][2] * z;\n"
"	ptrans->y = m->m[1][0] * x + m->m[1][1] * y + m->m[1][2] * z;\n"
"	ptrans->z = m->m[2][0] * x + m->m[2][1] * y + m->m[2][2] * z;\n"
"}\n"
"\n"
"void Triangle_Intersect(\n"
"		const float3 rayOrig,\n"
"		const float3 rayDir,\n"
"		const float mint,\n"
"		float *maxt,\n"
"		uint *hitIndex,\n"
"		float *hitB1,\n"
"		float *hitB2,\n"
"		const uint currentIndex,\n"
"		const float3 v0,\n"
"		const float3 v1,\n"
"		const float3 v2) {\n"
"\n"
"	// Calculate intersection\n"
"	const float3 e1 = v1 - v0;\n"
"	const float3 e2 = v2 - v0;\n"
"	const float3 s1 = cross(rayDir, e2);\n"
"\n"
"	const float divisor = dot(s1, e1);\n"
"	if (divisor == 0.f)\n"
"		return;\n"
"\n"
"	const float invDivisor = 1.f / divisor;\n"
"\n"
"	// Compute first barycentric coordinate\n"
"	const float3 d = rayOrig - v0;\n"
"	const float b1 = dot(d, s1) * invDivisor;\n"
"	if (b1 < 0.f)\n"
"		return;\n"
"\n"
"	// Compute second barycentric coordinate\n"
"	const float3 s2 = cross(d, e1);\n"
"	const float b2 = dot(rayDir, s2) * invDivisor;\n"
"	if (b2 < 0.f)\n"
"		return;\n"
"\n"
"	const float b0 = 1.f - b1 - b2;\n"
"	if (b0 < 0.f)\n"
"		return;\n"
"\n"
"	// Compute _t_ to intersection point\n"
"	const float t = dot(e2, s2) * invDivisor;\n"
"	if (t < mint || t > *maxt)\n"
"		return;\n"
"\n"
"	*maxt = t;\n"
"	*hitB1 = b1;\n"
"	*hitB2 = b2;\n"
"	*hitIndex = currentIndex;\n"
"}\n"
"\n"
"int BBox_IntersectP(\n"
"		const float3 rayOrig, const float3 rayDir,\n"
"		const float mint, const float maxt,\n"
"		const float3 pMin, const float3 pMax) {\n"
"	const float3 l1 = (pMin - rayOrig) / rayDir;\n"
"	const float3 l2 = (pMax - rayOrig) / rayDir;\n"
"	const float3 tNear = fmin(l1, l2);\n"
"	const float3 tFar = fmax(l1, l2);\n"
"\n"
"	float t0 = fmax(fmax(fmax(tNear.x, tNear.y), fmax(tNear.x, tNear.z)), mint);\n"
"    float t1 = fmin(fmin(fmin(tFar.x, tFar.y), fmin(tFar.x, tFar.z)), maxt);\n"
"\n"
"	return (t1 > t0);\n"
"}\n"
"\n"
"#if (BVH_NODES_PAGE_COUNT > 1)\n"
"void NextNode(uint *pageIndex, uint *nodeIndex) {\n"
"	++(*nodeIndex);\n"
"	if (*nodeIndex >= BVH_NODES_PAGE_SIZE) {\n"
"		*nodeIndex = 0;\n"
"		++(*pageIndex);\n"
"	}\n"
"}\n"
"#endif\n"
"\n"
"__kernel void Intersect(\n"
"		__global Ray *rays,\n"
"		__global RayHit *rayHits,\n"
"		const uint rayCount\n"
"#if defined(MBVH_HAS_TRANSFORMATIONS)\n"
"		, __global Matrix4x4 *leafTransformations\n"
"#endif\n"
"#if defined(MBVH_VERTS_PAGE0)\n"
"		, __global Point *vertPage0\n"
"#endif\n"
"#if defined(MBVH_VERTS_PAGE1)\n"
"		, __global Point *vertPage1\n"
"#endif\n"
"#if defined(MBVH_VERTS_PAGE2)\n"
"		, __global Point *vertPage2\n"
"#endif\n"
"#if defined(MBVH_VERTS_PAGE3)\n"
"		, __global Point *vertPage3\n"
"#endif\n"
"#if defined(MBVH_VERTS_PAGE4)\n"
"		, __global Point *vertPage4\n"
"#endif\n"
"#if defined(MBVH_VERTS_PAGE5)\n"
"		, __global Point *vertPage5\n"
"#endif\n"
"#if defined(MBVH_VERTS_PAGE6)\n"
"		, __global Point *vertPage6\n"
"#endif\n"
"#if defined(MBVH_VERTS_PAGE7)\n"
"		, __global Point *vertPage7\n"
"#endif\n"
"#if defined(MBVH_NODES_PAGE0)\n"
"		, __global BVHAccelArrayNode *nodePage0\n"
"#endif\n"
"#if defined(MBVH_NODES_PAGE1)\n"
"		, __global BVHAccelArrayNode *nodePage1\n"
"#endif\n"
"#if defined(MBVH_NODES_PAGE2)\n"
"		, __global BVHAccelArrayNode *nodePage2\n"
"#endif\n"
"#if defined(MBVH_NODES_PAGE3)\n"
"		, __global BVHAccelArrayNode *nodePage3\n"
"#endif\n"
"#if defined(MBVH_NODES_PAGE4)\n"
"		, __global BVHAccelArrayNode *nodePage4\n"
"#endif\n"
"#if defined(MBVH_NODES_PAGE5)\n"
"		, __global BVHAccelArrayNode *nodePage5\n"
"#endif\n"
"#if defined(MBVH_NODES_PAGE6)\n"
"		, __global BVHAccelArrayNode *nodePage6\n"
"#endif\n"
"#if defined(MBVH_NODES_PAGE7)\n"
"		, __global BVHAccelArrayNode *nodePage7\n"
"#endif\n"
"		) {\n"
"	// Select the ray to check\n"
"	const int gid = get_global_id(0);\n"
"	if (gid >= rayCount)\n"
"		return;\n"
"\n"
"	// Initialize vertex page references\n"
"#if (MBVH_VERTS_PAGE_COUNT > 1)\n"
"	__global Point *vertPages[MBVH_VERTS_PAGE_COUNT];\n"
"#if defined(MBVH_VERTS_PAGE0)\n"
"	vertPages[0] = vertPage0;\n"
"#endif\n"
"#if defined(MBVH_VERTS_PAGE1)\n"
"	vertPages[1] = vertPage1;\n"
"#endif\n"
"#if defined(MBVH_VERTS_PAGE2)\n"
"	vertPages[2] = vertPage2;\n"
"#endif\n"
"#if defined(MBVH_VERTS_PAGE3)\n"
"	vertPages[3] = vertPage3;\n"
"#endif\n"
"#if defined(MBVH_VERTS_PAGE4)\n"
"	vertPages[4] = vertPage4;\n"
"#endif\n"
"#if defined(MBVH_VERTS_PAGE5)\n"
"	vertPages[5] = vertPage5;\n"
"#endif\n"
"#if defined(MBVH_VERTS_PAGE6)\n"
"	vertPages[6] = vertPage6;\n"
"#endif\n"
"#if defined(MBVH_VERTS_PAGE7)\n"
"	vertPages[7] = vertPage7;\n"
"#endif\n"
"#endif\n"
"\n"
"	// Initialize node page references\n"
"#if (MBVH_NODES_PAGE_COUNT > 1)\n"
"	__global BVHAccelArrayNode *nodePages[MBVH_NODES_PAGE_COUNT];\n"
"#if defined(MBVH_NODES_PAGE0)\n"
"	nodePages[0] = nodePage0;\n"
"#endif\n"
"#if defined(MBVH_NODES_PAGE1)\n"
"	nodePages[1] = nodePage1;\n"
"#endif\n"
"#if defined(MBVH_NODES_PAGE2)\n"
"	nodePages[2] = nodePage2;\n"
"#endif\n"
"#if defined(MBVH_NODES_PAGE3)\n"
"	nodePages[3] = nodePage3;\n"
"#endif\n"
"#if defined(MBVH_NODES_PAGE4)\n"
"	nodePages[4] = nodePage4;\n"
"#endif\n"
"#if defined(MBVH_NODES_PAGE5)\n"
"	nodePages[5] = nodePage5;\n"
"#endif\n"
"#if defined(MBVH_NODES_PAGE6)\n"
"	nodePages[6] = nodePage6;\n"
"#endif\n"
"#if defined(MBVH_NODES_PAGE7)\n"
"	nodePages[7] = nodePage7;\n"
"#endif\n"
"#endif\n"
"\n"
"	bool insideLeafTree = false;\n"
"#if (MBVH_NODES_PAGE_COUNT == 1)\n"
"	uint currentRootNode = 0;\n"
"	uint rootStopNode = BVHNodeData_GetSkipIndex(nodePage0[0].nodeData); // Non-existent\n"
"	uint currentStopNode = rootStopNode; // Non-existent\n"
"	uint currentNode = currentRootNode;\n"
"#else\n"
"	uint currentRootPage = 0;\n"
"	uint currentRootNode = 0;\n"
"\n"
"	const uint rootStopPage = BVHNodeData_GetPageIndex(nodePage0[0].nodeData);\n"
"	const uint rootStopNode = BVHNodeData_GetNodeIndex(nodePage0[0].nodeData); // Non-existent\n"
"\n"
"	uint currentStopPage = rootStopPage; // Non-existent\n"
"	uint currentStopNode = rootStopNode; // Non-existent\n"
"\n"
"	uint currentPage = 0; // Root Node Page\n"
"	uint currentNode = currentRootNode;\n"
"#endif\n"
"	\n"
"	uint currentTriangleOffset = 0;\n"
"\n"
"	__global Ray *ray = &rays[gid];\n"
"	const float3 rootRayOrig = VLOAD3F(&ray->o.x);\n"
"	float3 currentRayOrig = rootRayOrig;\n"
"	const float3 rootRayDir = VLOAD3F(&ray->d.x);\n"
"	float3 currentRayDir = rootRayDir;\n"
"	const float mint = ray->mint;\n"
"	float maxt = ray->maxt;\n"
"\n"
"	uint hitIndex = NULL_INDEX;\n"
"\n"
"	float t, b1, b2;\n"
"	for (;;) {\n"
"#if (MBVH_NODES_PAGE_COUNT == 1)\n"
"		if (currentNode >= currentStopNode) {\n"
"#else\n"
"		if ((currentPage >= currentStopPage) && (currentNode >= currentStopNode)) {\n"
"#endif\n"
"			if (insideLeafTree) {\n"
"				// Go back to the root tree\n"
"#if (MBVH_NODES_PAGE_COUNT == 1)\n"
"				currentNode = currentRootNode;\n"
"				currentStopNode = rootStopNode;\n"
"#else\n"
"				currentPage = currentRootPage;\n"
"				currentNode = currentRootNode;\n"
"				currentStopPage = rootStopPage;\n"
"				currentStopNode = rootStopNode;\n"
"#endif\n"
"				currentRayOrig = rootRayOrig;\n"
"				currentRayDir = rootRayDir;\n"
"				insideLeafTree = false;\n"
"\n"
"				// Check if the leaf was the very last root node\n"
"#if (MBVH_NODES_PAGE_COUNT == 1)\n"
"				if (currentNode >= currentStopNode)\n"
"#else\n"
"				if ((currentPage >= currentStopPage) && (currentNode >= currentStopNode))\n"
"#endif\n"
"					break;\n"
"			} else {\n"
"				// Done\n"
"				break;\n"
"			}\n"
"		}\n"
"\n"
"#if (MBVH_NODES_PAGE_COUNT == 1)\n"
"		__global BVHAccelArrayNode *node = &nodePage0[currentNode];\n"
"#else\n"
"		__global BVHAccelArrayNode *nodePage = nodePages[currentPage];\n"
"		__global BVHAccelArrayNode *node = &nodePages[currentNode];\n"
"#endif\n"
"		const uint nodeData = node->nodeData;\n"
"		if (BVHNodeData_IsLeaf(nodeData)) {\n"
"			if (insideLeafTree) {\n"
"				// I'm inside a leaf tree, I have to check the triangle\n"
"#if (MBVH_VERTS_PAGE_COUNT == 1)\n"
"				// Fast path for when there is only one memory page\n"
"				const float3 p0 = VLOAD3F(&vertPage0[node->triangleLeaf.v[0]].x);\n"
"				const float3 p1 = VLOAD3F(&vertPage0[node->triangleLeaf.v[1]].x);\n"
"				const float3 p2 = VLOAD3F(&vertPage0[node->triangleLeaf.v[2]].x);\n"
"#else\n"
"				const uint v0 = node->triangleLeaf.v[0];\n"
"				const uint pv0 = (v0 & 0xe0000000u) >> 29;\n"
"				const uint iv0 = (v0 & 0x1fffffffu);\n"
"				__global Point *vp0 = vertPages[pv0];\n"
"				const float3 p0 = VLOAD3F(&vp0[iv0].x);\n"
"\n"
"				const uint v1 = node->triangleLeaf.v[1];\n"
"				const uint pv1 = (v1 & 0xe0000000u) >> 29;\n"
"				const uint iv1 = (v1 & 0x1fffffffu);\n"
"				__global Point *vp1 = vertPages[pv1];\n"
"				const float3 p1 = VLOAD3F(&vp1[iv1].x);\n"
"\n"
"				const uint v2 = node->triangleLeaf.v[2];\n"
"				const uint pv2 = (v2 & 0xe0000000u) >> 29;\n"
"				const uint iv2 = (v2 & 0x1fffffffu);\n"
"				__global Point *vp2 = vertPages[pv2];\n"
"				const float3 p2 = VLOAD3F(&vp2[iv2].x);\n"
"#endif\n"
"\n"
"				Triangle_Intersect(currentRayOrig, currentRayDir, mint, &maxt, &hitIndex, &b1, &b2,\n"
"					node->triangleLeaf.triangleIndex + currentTriangleOffset, p0, p1, p2);\n"
"				++currentNode;\n"
"			} else {\n"
"				// I have to check a leaf tree\n"
"#if defined(MBVH_HAS_TRANSFORMATIONS)\n"
"				// Transform the ray in the local coordinate system\n"
"				if (node->bvhLeaf.transformIndex != NULL_INDEX) {\n"
"					// Transform ray origin\n"
"					__global Matrix4x4 *m = &leafTransformations[node->bvhLeaf.transformIndex];\n"
"					TransformP(&currentRayOrig, &rootRayOrig, m);\n"
"					TransformV(&currentRayDir, &rootRayDir, m);\n"
"				}\n"
"#endif \n"
"				currentTriangleOffset = node->bvhLeaf.triangleOffsetIndex;\n"
"\n"
"				currentRootNode = currentNode + 1;\n"
"				currentNode = node->bvhLeaf.leafIndex;\n"
"				currentStopNode = BVHNodeData_GetSkipIndex(nodePage0[currentNode].nodeData);\n"
"\n"
"				// Now, I'm inside a leaf tree\n"
"				insideLeafTree = true;\n"
"			}\n"
"		} else {\n"
"			// It is a node, check the bounding box\n"
"			const float3 pMin = VLOAD3F(&node->bvhNode.bboxMin[0]);\n"
"			const float3 pMax = VLOAD3F(&node->bvhNode.bboxMax[0]);\n"
"\n"
"			if (BBox_IntersectP(currentRayOrig, currentRayDir, mint, maxt, pMin, pMax))\n"
"				++currentNode;\n"
"			else {\n"
"				// I don't need to use BVHNodeData_GetSkipIndex() here because\n"
"				// I already know the leaf flag is 0\n"
"				currentNode = nodeData;\n"
"			}\n"
"		}\n"
"	}\n"
"\n"
"	// Write result\n"
"	__global RayHit *rayHit = &rayHits[gid];\n"
"	rayHit->t = maxt;\n"
"	rayHit->b1 = b1;\n"
"	rayHit->b2 = b2;\n"
"	rayHit->index = hitIndex;\n"
"}\n"
; } }
