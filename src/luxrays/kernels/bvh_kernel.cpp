#include <string>
namespace luxrays { namespace ocl {
std::string KernelSource_bvh = 
"#line 2 \"bvh_kernel.cl\"\n"
"\n"
"/***************************************************************************\n"
" *   Copyright (C) 1998-2013 by authors (see AUTHORS.txt)                  *\n"
" *                                                                         *\n"
" *   This file is part of LuxRays.                                         *\n"
" *                                                                         *\n"
" *   LuxRays is free software; you can redistribute it and/or modify       *\n"
" *   it under the terms of the GNU General Public License as published by  *\n"
" *   the Free Software Foundation; either version 3 of the License, or     *\n"
" *   (at your option) any later version.                                   *\n"
" *                                                                         *\n"
" *   LuxRays is distributed in the hope that it will be useful,            *\n"
" *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *\n"
" *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *\n"
" *   GNU General Public License for more details.                          *\n"
" *                                                                         *\n"
" *   You should have received a copy of the GNU General Public License     *\n"
" *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *\n"
" *                                                                         *\n"
" *   LuxRays website: http://www.luxrender.net                             *\n"
" ***************************************************************************/\n"
"\n"
"\n"
"typedef struct {\n"
"	union {\n"
"		struct {\n"
"			// I can not use BBox here because objects with a constructor are not\n"
"			// allowed inside an union.\n"
"			float bboxMin[3];\n"
"			float bboxMax[3];\n"
"		} bvhNode;\n"
"		struct {\n"
"			uint v[3];\n"
"			uint triangleIndex;\n"
"		} triangleLeaf;\n"
"		struct {\n"
"			uint index;\n"
"		} bvhLeaf;\n"
"	};\n"
"	// Most significant bit is used to mark leafs\n"
"	uint nodeData;\n"
"} BVHAccelArrayNode;\n"
"\n"
"#define BVHNodeData_IsLeaf(nodeData) ((nodeData) & 0x80000000u)\n"
"#define BVHNodeData_GetSkipIndex(nodeData) ((nodeData) & 0x7fffffffu)\n"
"\n"
"void Triangle_Intersect(\n"
"		const float3 rayOrig,\n"
"		const float3 rayDir,\n"
"		const float mint,\n"
"		float *maxt,\n"
"		uint *hitIndex,\n"
"		float *hitB1,\n"
"		float *hitB2,\n"
"		const uint currentIndex,\n"
"		const float3 v0,\n"
"		const float3 v1,\n"
"		const float3 v2) {\n"
"\n"
"	// Calculate intersection\n"
"	const float3 e1 = v1 - v0;\n"
"	const float3 e2 = v2 - v0;\n"
"	const float3 s1 = cross(rayDir, e2);\n"
"\n"
"	const float divisor = dot(s1, e1);\n"
"	if (divisor == 0.f)\n"
"		return;\n"
"\n"
"	const float invDivisor = 1.f / divisor;\n"
"\n"
"	// Compute first barycentric coordinate\n"
"	const float3 d = rayOrig - v0;\n"
"	const float b1 = dot(d, s1) * invDivisor;\n"
"	if (b1 < 0.f)\n"
"		return;\n"
"\n"
"	// Compute second barycentric coordinate\n"
"	const float3 s2 = cross(d, e1);\n"
"	const float b2 = dot(rayDir, s2) * invDivisor;\n"
"	if (b2 < 0.f)\n"
"		return;\n"
"\n"
"	const float b0 = 1.f - b1 - b2;\n"
"	if (b0 < 0.f)\n"
"		return;\n"
"\n"
"	// Compute _t_ to intersection point\n"
"	const float t = dot(e2, s2) * invDivisor;\n"
"	if (t < mint || t > *maxt)\n"
"		return;\n"
"\n"
"	*maxt = t;\n"
"	*hitB1 = b1;\n"
"	*hitB2 = b2;\n"
"	*hitIndex = currentIndex;\n"
"}\n"
"\n"
"int BBox_IntersectP(\n"
"		const float3 rayOrig, const float3 invRayDir,\n"
"		const float mint, const float maxt,\n"
"		const float3 pMin, const float3 pMax) {\n"
"	const float3 l1 = (pMin - rayOrig) * invRayDir;\n"
"	const float3 l2 = (pMax - rayOrig) * invRayDir;\n"
"	const float3 tNear = fmin(l1, l2);\n"
"	const float3 tFar = fmax(l1, l2);\n"
"\n"
"	float t0 = fmax(fmax(fmax(tNear.x, tNear.y), fmax(tNear.x, tNear.z)), mint);\n"
"    float t1 = fmin(fmin(fmin(tFar.x, tFar.y), fmin(tFar.x, tFar.z)), maxt);\n"
"\n"
"	return (t1 > t0);\n"
"}\n"
"\n"
"__kernel void Intersect(\n"
"		__global Ray *rays,\n"
"		__global RayHit *rayHits,\n"
"		__global Point *verts,\n"
"		__global BVHAccelArrayNode *bvhTree,\n"
"		const uint rayCount) {\n"
"	// Select the ray to check\n"
"	const int gid = get_global_id(0);\n"
"	if (gid >= rayCount)\n"
"		return;\n"
"\n"
"	__global Ray *ray = &rays[gid];\n"
"	const float3 rayOrig = VLOAD3F(&ray->o.x);\n"
"	const float3 rayDir = VLOAD3F(&ray->d.x);\n"
"	const float mint = ray->mint;\n"
"	float maxt = ray->maxt;\n"
"\n"
"	const float3 invRayDir = 1.f / rayDir;\n"
"\n"
"	uint hitIndex = NULL_INDEX;\n"
"	uint currentNode = 0; // Root Node\n"
"	const uint stopNode = BVHNodeData_GetSkipIndex(bvhTree[0].nodeData); // Non-existent\n"
"\n"
"	float b1, b2;\n"
"	while (currentNode < stopNode) {\n"
"		__global BVHAccelArrayNode *node = &bvhTree[currentNode];\n"
"\n"
"		const uint nodeData = node->nodeData;\n"
"		if (BVHNodeData_IsLeaf(nodeData)) {\n"
"			// It is a leaf, check the triangle\n"
"			const float3 p0 = VLOAD3F(&verts[node->triangleLeaf.v[0]].x);\n"
"			const float3 p1 = VLOAD3F(&verts[node->triangleLeaf.v[1]].x);\n"
"			const float3 p2 = VLOAD3F(&verts[node->triangleLeaf.v[2]].x);\n"
"\n"
"			Triangle_Intersect(rayOrig, rayDir, mint, &maxt, &hitIndex, &b1, &b2,\n"
"					node->triangleLeaf.triangleIndex, p0, p1, p2);\n"
"			++currentNode;\n"
"		} else {\n"
"			// It is a node, check the bounding box\n"
"			const float3 pMin = VLOAD3F(&node->bvhNode.bboxMin[0]);\n"
"			const float3 pMax = VLOAD3F(&node->bvhNode.bboxMax[0]);\n"
"\n"
"			if (BBox_IntersectP(rayOrig, invRayDir, mint, maxt, pMin, pMax))\n"
"				++currentNode;\n"
"			else {\n"
"				// I don't need to use BVHNodeData_GetSkipIndex() here because\n"
"				// I already know the flag is 0\n"
"				currentNode = nodeData;\n"
"			}\n"
"		}\n"
"	}\n"
"\n"
"	// Write result\n"
"	__global RayHit *rayHit = &rayHits[gid];\n"
"	rayHit->t = maxt;\n"
"	rayHit->b1 = b1;\n"
"	rayHit->b2 = b2;\n"
"	rayHit->index = hitIndex;\n"
"}\n"
; } }
