#include <string>
namespace slg { namespace ocl {
std::string KernelSource_pathoclbase_funcs = 
"#line 2 \"patchoclbase_kernels.cl\"\n"
"\n"
"/***************************************************************************\n"
" *   Copyright (C) 1998-2013 by authors (see AUTHORS.txt)                  *\n"
" *                                                                         *\n"
" *   This file is part of LuxRays.                                         *\n"
" *                                                                         *\n"
" *   LuxRays is free software; you can redistribute it and/or modify       *\n"
" *   it under the terms of the GNU General Public License as published by  *\n"
" *   the Free Software Foundation; either version 3 of the License, or     *\n"
" *   (at your option) any later version.                                   *\n"
" *                                                                         *\n"
" *   LuxRays is distributed in the hope that it will be useful,            *\n"
" *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *\n"
" *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *\n"
" *   GNU General Public License for more details.                          *\n"
" *                                                                         *\n"
" *   You should have received a copy of the GNU General Public License     *\n"
" *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *\n"
" *                                                                         *\n"
" *   LuxRays website: http://www.luxrender.net                             *\n"
" ***************************************************************************/\n"
"\n"
"// List of symbols defined at compile time:\n"
"//  PARAM_TASK_COUNT\n"
"//  PARAM_RAY_EPSILON_MIN\n"
"//  PARAM_RAY_EPSILON_MAX\n"
"//  PARAM_HAS_IMAGEMAPS\n"
"//  PARAM_HAS_PASSTHROUGH\n"
"//  PARAM_USE_PIXEL_ATOMICS\n"
"//  PARAM_HAS_BUMPMAPS\n"
"//  PARAM_HAS_NORMALMAPS\n"
"//  PARAM_ACCEL_BVH or PARAM_ACCEL_MBVH or PARAM_ACCEL_QBVH or PARAM_ACCEL_MQBVH\n"
"//  PARAM_DEVICE_INDEX\n"
"//  PARAM_DEVICE_COUNT\n"
"//  PARAM_LIGHT_WORLD_RADIUS_SCALE\n"
"//  PARAM_TRIANGLE_LIGHT_COUNT\n"
"//  PARAM_LIGHT_COUNT\n"
"\n"
"// To enable single material support\n"
"//  PARAM_ENABLE_MAT_MATTE\n"
"//  PARAM_ENABLE_MAT_MIRROR\n"
"//  PARAM_ENABLE_MAT_GLASS\n"
"//  PARAM_ENABLE_MAT_METAL\n"
"//  PARAM_ENABLE_MAT_ARCHGLASS\n"
"//  PARAM_ENABLE_MAT_MIX\n"
"//  PARAM_ENABLE_MAT_NULL\n"
"//  PARAM_ENABLE_MAT_MATTETRANSLUCENT\n"
"\n"
"// To enable single texture support\n"
"//  PARAM_ENABLE_TEX_CONST_FLOAT\n"
"//  PARAM_ENABLE_TEX_CONST_FLOAT3\n"
"//  PARAM_ENABLE_TEX_CONST_FLOAT4\n"
"//  PARAM_ENABLE_TEX_IMAGEMAP\n"
"//  PARAM_ENABLE_TEX_SCALE\n"
"\n"
"// Film related parameters:\n"
"//  PARAM_FILM_RADIANCE_GROUP_COUNT\n"
"//  PARAM_FILM_CHANNELS_HAS_ALPHA\n"
"//  PARAM_FILM_CHANNELS_HAS_DEPTH\n"
"//  PARAM_FILM_CHANNELS_HAS_POSITION\n"
"//  PARAM_FILM_CHANNELS_HAS_GEOMETRY_NORMAL\n"
"//  PARAM_FILM_CHANNELS_HAS_SHADING_NORMAL\n"
"//  PARAM_FILM_CHANNELS_HAS_MATERIAL_ID\n"
"//  PARAM_FILM_CHANNELS_HAS_MATERIAL_ID\n"
"//  PARAM_FILM_CHANNELS_HAS_DIRECT_DIFFUSE\n"
"//  PARAM_FILM_CHANNELS_HAS_DIRECT_GLOSSY\n"
"//  PARAM_FILM_CHANNELS_HAS_EMISSION\n"
"//  PARAM_FILM_CHANNELS_HAS_INDIRECT_DIFFUSE\n"
"//  PARAM_FILM_CHANNELS_HAS_INDIRECT_GLOSSY\n"
"//  PARAM_FILM_CHANNELS_HAS_INDIRECT_SPECULAR\n"
"//  PARAM_FILM_CHANNELS_HAS_MATERIAL_ID_MASK (and PARAM_FILM_MASK_MATERIAL_ID)\n"
"//  PARAM_FILM_CHANNELS_HAS_DIRECT_SHADOW_MASK\n"
"//  PARAM_FILM_CHANNELS_HAS_INDIRECT_SHADOW_MASK\n"
"//  PARAM_FILM_CHANNELS_HAS_UV\n"
"//  PARAM_FILM_CHANNELS_HAS_RAYCOUNT\n"
"\n"
"// (optional)\n"
"//  PARAM_CAMERA_HAS_DOF\n"
"\n"
"// (optional)\n"
"//  PARAM_HAS_INFINITELIGHT\n"
"\n"
"// (optional)\n"
"//  PARAM_HAS_SUNLIGHT\n"
"\n"
"// (optional)\n"
"//  PARAM_HAS_SKYLIGHT\n"
"\n"
"// (optional)\n"
"//  PARAM_HAS_NORMALS_BUFFER\n"
"//  PARAM_HAS_UVS_BUFFER\n"
"//  PARAM_HAS_COLS_BUFFER\n"
"//  PARAM_HAS_ALPHAS_BUFFER\n"
"\n"
"void AddEmission(const bool firstPathVertex, const BSDFEvent pathBSDFEvent,\n"
"		__global SampleResult *sampleResult, const float3 emission) {\n"
"	if (firstPathVertex) {\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_EMISSION)\n"
"		VADD3F(&sampleResult->emission.r, emission);\n"
"#endif\n"
"	} else {\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SHADOW_MASK)\n"
"		sampleResult->indirectShadowMask = 0.f;\n"
"#endif\n"
"		if (pathBSDFEvent & DIFFUSE) {\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_DIFFUSE)\n"
"			VADD3F(&sampleResult->indirectDiffuse.r, emission);\n"
"#endif\n"
"		} else if (pathBSDFEvent & GLOSSY) {\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_GLOSSY)\n"
"			VADD3F(&sampleResult->indirectGlossy.r, emission);\n"
"#endif\n"
"		} else if (pathBSDFEvent & SPECULAR) {\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SPECULAR)\n"
"			VADD3F(&sampleResult->indirectSpecular.r, emission);\n"
"#endif\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"#if defined(PARAM_HAS_SKYLIGHT) || defined(PARAM_HAS_INFINITELIGHT) || defined(PARAM_HAS_SUNLIGHT)\n"
"void DirectHitInfiniteLight(\n"
"		const bool firstPathVertex,\n"
"		const BSDFEvent lastBSDFEvent,\n"
"		const BSDFEvent pathBSDFEvent,\n"
"		__global float *lightsDistribution,\n"
"#if defined(PARAM_HAS_INFINITELIGHT)\n"
"		__global InfiniteLight *infiniteLight,\n"
"		__global float *infiniteLightDistribution,\n"
"#endif\n"
"#if defined(PARAM_HAS_SUNLIGHT)\n"
"		__global SunLight *sunLight,\n"
"#endif\n"
"#if defined(PARAM_HAS_SKYLIGHT)\n"
"		__global SkyLight *skyLight,\n"
"#endif\n"
"		__global const Spectrum *pathThroughput,\n"
"		const float3 eyeDir, const float lastPdfW,\n"
"		__global SampleResult *sampleResult\n"
"		IMAGEMAPS_PARAM_DECL) {\n"
"	const float3 throughput = VLOAD3F(&pathThroughput->r);\n"
"\n"
"#if defined(PARAM_HAS_INFINITELIGHT)\n"
"	{\n"
"		float directPdfW;\n"
"		const float3 infiniteLightRadiance = InfiniteLight_GetRadiance(infiniteLight,\n"
"				infiniteLightDistribution, eyeDir, &directPdfW\n"
"				IMAGEMAPS_PARAM);\n"
"		if (!Spectrum_IsBlack(infiniteLightRadiance)) {\n"
"			// MIS between BSDF sampling and direct light sampling\n"
"			const float lightPickProb = Scene_SampleAllLightPdf(lightsDistribution, infiniteLight->lightSceneIndex);\n"
"			const float weight = ((lastBSDFEvent & SPECULAR) ? 1.f : PowerHeuristic(lastPdfW, directPdfW * lightPickProb));\n"
"			const float3 lightRadiance = weight * throughput * infiniteLightRadiance;\n"
"\n"
"			const uint lightID = min(infiniteLight->lightID, PARAM_FILM_RADIANCE_GROUP_COUNT - 1u);\n"
"			VADD3F(&sampleResult->radiancePerPixelNormalized[lightID].r, lightRadiance);\n"
"\n"
"			AddEmission(firstPathVertex, pathBSDFEvent, sampleResult, lightRadiance);\n"
"		}\n"
"	}\n"
"#endif\n"
"#if defined(PARAM_HAS_SKYLIGHT)\n"
"	{\n"
"		float directPdfW;\n"
"		const float3 skyRadiance = SkyLight_GetRadiance(skyLight, eyeDir, &directPdfW);\n"
"		if (!Spectrum_IsBlack(skyRadiance)) {\n"
"			// MIS between BSDF sampling and direct light sampling\n"
"			const float lightPickProb = Scene_SampleAllLightPdf(lightsDistribution, skyLight->lightSceneIndex);\n"
"			const float weight = ((lastBSDFEvent & SPECULAR) ? 1.f : PowerHeuristic(lastPdfW, directPdfW * lightPickProb));\n"
"			const float3 lightRadiance = weight * throughput * skyRadiance;\n"
"\n"
"			const uint lightID = min(skyLight->lightID, PARAM_FILM_RADIANCE_GROUP_COUNT - 1u);\n"
"			VADD3F(&sampleResult->radiancePerPixelNormalized[lightID].r, lightRadiance);\n"
"\n"
"			AddEmission(firstPathVertex, pathBSDFEvent, sampleResult, lightRadiance);\n"
"		}\n"
"	}\n"
"#endif\n"
"#if defined(PARAM_HAS_SUNLIGHT)\n"
"	{\n"
"		float directPdfW;\n"
"		const float3 sunRadiance = SunLight_GetRadiance(sunLight, eyeDir, &directPdfW);\n"
"		if (!Spectrum_IsBlack(sunRadiance)) {\n"
"			// MIS between BSDF sampling and direct light sampling\n"
"			const float lightPickProb = Scene_SampleAllLightPdf(lightsDistribution, sunLight->lightSceneIndex);\n"
"			const float weight = ((lastBSDFEvent & SPECULAR) ? 1.f : PowerHeuristic(lastPdfW, directPdfW * lightPickProb));\n"
"			const float3 lightRadiance = weight * throughput * sunRadiance;\n"
"\n"
"			const uint lightID = min(sunLight->lightID, PARAM_FILM_RADIANCE_GROUP_COUNT - 1u);\n"
"			VADD3F(&sampleResult->radiancePerPixelNormalized[lightID].r, lightRadiance);\n"
"\n"
"			AddEmission(firstPathVertex, pathBSDFEvent, sampleResult, lightRadiance);\n"
"		}\n"
"	}\n"
"#endif\n"
"}\n"
"#endif\n"
"\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"void DirectHitFiniteLight(\n"
"		const bool firstPathVertex,\n"
"		const BSDFEvent lastBSDFEvent,\n"
"		const BSDFEvent pathBSDFEvent,\n"
"		__global float *lightsDistribution,\n"
"		__global TriangleLight *triLightDefs,\n"
"		__global const Spectrum *pathThroughput, const float distance, __global BSDF *bsdf,\n"
"		const float lastPdfW, __global SampleResult *sampleResult\n"
"		MATERIALS_PARAM_DECL) {\n"
"	float directPdfA;\n"
"	const float3 emittedRadiance = BSDF_GetEmittedRadiance(bsdf,\n"
"			triLightDefs, &directPdfA\n"
"			MATERIALS_PARAM);\n"
"\n"
"	if (!Spectrum_IsBlack(emittedRadiance)) {\n"
"		// Add emitted radiance\n"
"		float weight = 1.f;\n"
"		if (!(lastBSDFEvent & SPECULAR)) {\n"
"			const float lightPickProb = Scene_SampleAllLightPdf(lightsDistribution,\n"
"					triLightDefs[bsdf->triangleLightSourceIndex].lightSceneIndex);\n"
"			const float directPdfW = PdfAtoW(directPdfA, distance,\n"
"				fabs(dot(VLOAD3F(&bsdf->hitPoint.fixedDir.x), VLOAD3F(&bsdf->hitPoint.shadeN.x))));\n"
"\n"
"			// MIS between BSDF sampling and direct light sampling\n"
"			weight = PowerHeuristic(lastPdfW, directPdfW * lightPickProb);\n"
"		}\n"
"		const float3 lightRadiance = weight * VLOAD3F(&pathThroughput->r) * emittedRadiance;\n"
"\n"
"		const uint lightID =  min(BSDF_GetLightID(bsdf\n"
"				MATERIALS_PARAM), PARAM_FILM_RADIANCE_GROUP_COUNT - 1u);\n"
"		VADD3F(&sampleResult->radiancePerPixelNormalized[lightID].r, lightRadiance);\n"
"\n"
"		AddEmission(firstPathVertex, pathBSDFEvent, sampleResult, lightRadiance);\n"
"	}\n"
"}\n"
"#endif\n"
"\n"
"#if !defined(DIRECTLIGHTSAMPLING_ONE_PARAM_DISABLE_RR)\n"
"float RussianRouletteProb(const float3 color) {\n"
"	return clamp(Spectrum_Filter(color), PARAM_RR_CAP, 1.f);\n"
"}\n"
"#endif\n"
"\n"
"bool DirectLightSampling(\n"
"		const uint lightIndex,\n"
"		const float lightPickPdf,\n"
"#if defined(PARAM_HAS_INFINITELIGHT) || defined(PARAM_HAS_SKYLIGHT)\n"
"		const float worldCenterX,\n"
"		const float worldCenterY,\n"
"		const float worldCenterZ,\n"
"		const float worldRadius,\n"
"#endif\n"
"#if defined(PARAM_HAS_INFINITELIGHT)\n"
"		__global InfiniteLight *infiniteLight,\n"
"		__global float *infiniteLightDistribution,\n"
"#endif\n"
"#if defined(PARAM_HAS_SUNLIGHT)\n"
"		__global SunLight *sunLight,\n"
"#endif\n"
"#if defined(PARAM_HAS_SKYLIGHT)\n"
"		__global SkyLight *skyLight,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"		__global TriangleLight *triLightDefs,\n"
"		__global HitPoint *tmpHitPoint,\n"
"#endif\n"
"		__global float *lightsDistribution,\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"		const float u3,\n"
"		__global float *shadowPassThrought,\n"
"#endif\n"
"		const float u0, const float u1, const float u2,\n"
"#if !defined(DIRECTLIGHTSAMPLING_ONE_PARAM_DISABLE_RR)\n"
"		const uint depth,\n"
"#endif\n"
"		__global const Spectrum *pathThroughput, __global BSDF *bsdf,\n"
"#if !defined(DIRECTLIGHTSAMPLING_PARAM_MEM_SPACE_PRIVATE)\n"
"		__global\n"
"#endif\n"
"		Ray *shadowRay, __global float *radiance, __global uint *ID\n"
"		MATERIALS_PARAM_DECL) {\n"
"	float3 lightRayDir;\n"
"	float distance, directPdfW;\n"
"	float3 lightRadiance;\n"
"	uint lightID;\n"
"\n"
"#if defined(PARAM_HAS_INFINITELIGHT)\n"
"	const uint infiniteLightIndex = PARAM_TRIANGLE_LIGHT_COUNT\n"
"#if defined(PARAM_HAS_SUNLIGHT)\n"
"		+ 1\n"
"#endif\n"
"	;\n"
"\n"
"	if (lightIndex == infiniteLightIndex) {\n"
"		lightRadiance = InfiniteLight_Illuminate(\n"
"			infiniteLight,\n"
"			infiniteLightDistribution,\n"
"			worldCenterX, worldCenterY, worldCenterZ, worldRadius,\n"
"			u0, u1,\n"
"			VLOAD3F(&bsdf->hitPoint.p.x),\n"
"			&lightRayDir, &distance, &directPdfW\n"
"			IMAGEMAPS_PARAM);\n"
"		lightID = infiniteLight->lightID;\n"
"	}\n"
"#endif\n"
"\n"
"#if defined(PARAM_HAS_SKYLIGHT)\n"
"	const uint skyLightIndex = PARAM_TRIANGLE_LIGHT_COUNT\n"
"#if defined(PARAM_HAS_SUNLIGHT)\n"
"		+ 1\n"
"#endif\n"
"	;\n"
"\n"
"	if (lightIndex == skyLightIndex) {\n"
"		lightRadiance = SkyLight_Illuminate(\n"
"			skyLight,\n"
"			worldCenterX, worldCenterY, worldCenterZ, worldRadius,\n"
"			u0, u1,\n"
"			VLOAD3F(&bsdf->hitPoint.p.x),\n"
"			&lightRayDir, &distance, &directPdfW);\n"
"		lightID = skyLight->lightID;\n"
"	}\n"
"#endif\n"
"\n"
"#if defined(PARAM_HAS_SUNLIGHT)\n"
"	const uint sunLightIndex = PARAM_TRIANGLE_LIGHT_COUNT;\n"
"	if (lightIndex == sunLightIndex) {\n"
"		lightRadiance = SunLight_Illuminate(\n"
"			sunLight,\n"
"			u0, u1,\n"
"			&lightRayDir, &distance, &directPdfW);\n"
"		lightID = sunLight->lightID;\n"
"	}\n"
"#endif\n"
"\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"	if (lightIndex < PARAM_TRIANGLE_LIGHT_COUNT) {\n"
"		lightRadiance = TriangleLight_Illuminate(\n"
"			&triLightDefs[lightIndex], tmpHitPoint,\n"
"			VLOAD3F(&bsdf->hitPoint.p.x),\n"
"			u0, u1, u2,\n"
"			&lightRayDir, &distance, &directPdfW\n"
"			MATERIALS_PARAM);\n"
"		lightID = mats[triLightDefs[lightIndex].materialIndex].lightID;\n"
"	}\n"
"#endif\n"
"\n"
"	// Setup the shadow ray\n"
"	if (!Spectrum_IsBlack(lightRadiance)) {\n"
"		BSDFEvent event;\n"
"		float bsdfPdfW;\n"
"		const float3 bsdfEval = BSDF_Evaluate(bsdf,\n"
"				lightRayDir, &event, &bsdfPdfW\n"
"				MATERIALS_PARAM);\n"
"\n"
"		if (!Spectrum_IsBlack(bsdfEval)) {\n"
"			const float cosThetaToLight = fabs(dot(lightRayDir, VLOAD3F(&bsdf->hitPoint.shadeN.x)));\n"
"			const float directLightSamplingPdfW = directPdfW * lightPickPdf;\n"
"			const float factor = cosThetaToLight / directLightSamplingPdfW;\n"
"\n"
"#if !defined(DIRECTLIGHTSAMPLING_ONE_PARAM_DISABLE_RR)\n"
"			// Russian Roulette\n"
"			bsdfPdfW *= (depth >= PARAM_RR_DEPTH) ? RussianRouletteProb(bsdfEval) : 1.f;\n"
"#endif\n"
"\n"
"			// MIS between direct light sampling and BSDF sampling\n"
"			const float weight = PowerHeuristic(directLightSamplingPdfW, bsdfPdfW);\n"
"\n"
"			VSTORE3F((weight * factor) * VLOAD3F(&pathThroughput->r) * bsdfEval * lightRadiance, radiance);\n"
"			*ID = min(lightID, PARAM_FILM_RADIANCE_GROUP_COUNT - 1u);\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"			*shadowPassThrought = u3;\n"
"#endif\n"
"\n"
"			// Setup the shadow ray\n"
"			const float3 hitPoint = VLOAD3F(&bsdf->hitPoint.p.x);\n"
"			const float epsilon = fmax(MachineEpsilon_E_Float3(hitPoint), MachineEpsilon_E(distance));\n"
"#if !defined(DIRECTLIGHTSAMPLING_PARAM_MEM_SPACE_PRIVATE)\n"
"			Ray_Init4(shadowRay, hitPoint, lightRayDir,\n"
"				epsilon,\n"
"				distance - epsilon);\n"
"#else\n"
"			Ray_Init4_Private(shadowRay, hitPoint, lightRayDir,\n"
"				epsilon,\n"
"				distance - epsilon);\n"
"#endif\n"
"\n"
"			return true;\n"
"		}\n"
"	}\n"
"\n"
"	return false;\n"
"}\n"
"\n"
"bool DirectLightSampling_ONE(\n"
"#if defined(PARAM_HAS_INFINITELIGHT) || defined(PARAM_HAS_SKYLIGHT)\n"
"		const float worldCenterX,\n"
"		const float worldCenterY,\n"
"		const float worldCenterZ,\n"
"		const float worldRadius,\n"
"#endif\n"
"#if defined(PARAM_HAS_INFINITELIGHT)\n"
"		__global InfiniteLight *infiniteLight,\n"
"		__global float *infiniteLightDistribution,\n"
"#endif\n"
"#if defined(PARAM_HAS_SUNLIGHT)\n"
"		__global SunLight *sunLight,\n"
"#endif\n"
"#if defined(PARAM_HAS_SKYLIGHT)\n"
"		__global SkyLight *skyLight,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"		__global TriangleLight *triLightDefs,\n"
"		__global HitPoint *tmpHitPoint,\n"
"#endif\n"
"		__global float *lightsDistribution,\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"		const float u4,\n"
"		__global float *shadowPassThrought,\n"
"#endif\n"
"		const float u0, const float u1, const float u2, const float u3,\n"
"#if !defined(DIRECTLIGHTSAMPLING_ONE_PARAM_DISABLE_RR)\n"
"		const uint depth,\n"
"#endif\n"
"		__global const Spectrum *pathThroughput, __global BSDF *bsdf,\n"
"#if !defined(DIRECTLIGHTSAMPLING_PARAM_MEM_SPACE_PRIVATE)\n"
"		__global\n"
"#endif\n"
"		Ray *shadowRay, __global float *radiance, __global uint *ID\n"
"		MATERIALS_PARAM_DECL) {\n"
"	// Pick a light source to sample\n"
"	float lightPickPdf;\n"
"	const uint lightIndex = Scene_SampleAllLights(lightsDistribution, u0, &lightPickPdf);\n"
"\n"
"	return DirectLightSampling(\n"
"		lightIndex,\n"
"		lightPickPdf,\n"
"#if defined(PARAM_HAS_INFINITELIGHT) || defined(PARAM_HAS_SKYLIGHT)\n"
"		worldCenterX,\n"
"		worldCenterY,\n"
"		worldCenterZ,\n"
"		worldRadius,\n"
"#endif\n"
"#if defined(PARAM_HAS_INFINITELIGHT)\n"
"		infiniteLight,\n"
"		infiniteLightDistribution,\n"
"#endif\n"
"#if defined(PARAM_HAS_SUNLIGHT)\n"
"		sunLight,\n"
"#endif\n"
"#if defined(PARAM_HAS_SKYLIGHT)\n"
"		skyLight,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"		triLightDefs,\n"
"		tmpHitPoint,\n"
"#endif\n"
"		lightsDistribution,\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"		u4,\n"
"		shadowPassThrought,\n"
"#endif\n"
"		u1, u2, u3,\n"
"#if !defined(DIRECTLIGHTSAMPLING_ONE_PARAM_DISABLE_RR)\n"
"		depth,\n"
"#endif\n"
"		pathThroughput, bsdf,\n"
"		shadowRay, radiance, ID\n"
"		MATERIALS_PARAM);\n"
"}\n"
"\n"
"bool DirectLightSampling_ALL(\n"
"		__global uint *currentLightIndex,\n"
"#if defined(PARAM_HAS_INFINITELIGHT) || defined(PARAM_HAS_SKYLIGHT)\n"
"		const float worldCenterX,\n"
"		const float worldCenterY,\n"
"		const float worldCenterZ,\n"
"		const float worldRadius,\n"
"#endif\n"
"#if defined(PARAM_HAS_INFINITELIGHT)\n"
"		__global InfiniteLight *infiniteLight,\n"
"		__global float *infiniteLightDistribution,\n"
"#endif\n"
"#if defined(PARAM_HAS_SUNLIGHT)\n"
"		__global SunLight *sunLight,\n"
"#endif\n"
"#if defined(PARAM_HAS_SKYLIGHT)\n"
"		__global SkyLight *skyLight,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"		__global TriangleLight *triLightDefs,\n"
"		__global HitPoint *tmpHitPoint,\n"
"#endif\n"
"		__global float *lightsDistribution,\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"		const float u4,\n"
"		__global float *shadowPassThrought,\n"
"#endif\n"
"		const float u0, const float u1, const float u2, const float u3,\n"
"#if !defined(DIRECTLIGHTSAMPLING_ONE_PARAM_DISABLE_RR)\n"
"		const uint depth,\n"
"#endif\n"
"		__global const Spectrum *pathThroughput, __global BSDF *bsdf,\n"
"#if !defined(DIRECTLIGHTSAMPLING_PARAM_MEM_SPACE_PRIVATE)\n"
"		__global\n"
"#endif\n"
"		Ray *shadowRay, __global float *radiance, __global uint *ID\n"
"		MATERIALS_PARAM_DECL) {\n"
"	for (; *currentLightIndex < PARAM_LIGHT_COUNT; ++(*currentLightIndex)) {\n"
"		if (DirectLightSampling(\n"
"			*currentLightIndex,\n"
"			1.f,\n"
"	#if defined(PARAM_HAS_INFINITELIGHT) || defined(PARAM_HAS_SKYLIGHT)\n"
"			worldCenterX,\n"
"			worldCenterY,\n"
"			worldCenterZ,\n"
"			worldRadius,\n"
"	#endif\n"
"	#if defined(PARAM_HAS_INFINITELIGHT)\n"
"			infiniteLight,\n"
"			infiniteLightDistribution,\n"
"	#endif\n"
"	#if defined(PARAM_HAS_SUNLIGHT)\n"
"			sunLight,\n"
"	#endif\n"
"	#if defined(PARAM_HAS_SKYLIGHT)\n"
"			skyLight,\n"
"	#endif\n"
"	#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"			triLightDefs,\n"
"			tmpHitPoint,\n"
"	#endif\n"
"			lightsDistribution,\n"
"	#if defined(PARAM_HAS_PASSTHROUGH)\n"
"			u4,\n"
"			shadowPassThrought,\n"
"	#endif\n"
"			u1, u2, u3,\n"
"	#if !defined(DIRECTLIGHTSAMPLING_ONE_PARAM_DISABLE_RR)\n"
"			depth,\n"
"	#endif\n"
"			pathThroughput, bsdf,\n"
"			shadowRay, radiance, ID\n"
"			MATERIALS_PARAM)) {\n"
"			return true;\n"
"		}\n"
"	}\n"
"\n"
"	return false;\n"
"}\n"
; } }
