#include <string>
namespace slg { namespace ocl {
std::string KernelSource_biaspathocl_kernels = 
"#line 2 \"biaspatchocl_kernels.cl\"\n"
"\n"
"/***************************************************************************\n"
" *   Copyright (C) 1998-2013 by authors (see AUTHORS.txt)                  *\n"
" *                                                                         *\n"
" *   This file is part of LuxRays.                                         *\n"
" *                                                                         *\n"
" *   LuxRays is free software; you can redistribute it and/or modify       *\n"
" *   it under the terms of the GNU General Public License as published by  *\n"
" *   the Free Software Foundation; either version 3 of the License, or     *\n"
" *   (at your option) any later version.                                   *\n"
" *                                                                         *\n"
" *   LuxRays is distributed in the hope that it will be useful,            *\n"
" *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *\n"
" *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *\n"
" *   GNU General Public License for more details.                          *\n"
" *                                                                         *\n"
" *   You should have received a copy of the GNU General Public License     *\n"
" *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *\n"
" *                                                                         *\n"
" *   LuxRays website: http://www.luxrender.net                             *\n"
" ***************************************************************************/\n"
"\n"
"// List of symbols defined at compile time:\n"
"//  PARAM_TASK_COUNT\n"
"//  PARAM_TILE_SIZE\n"
"//  PARAM_TILE_PROGRESSIVE_REFINEMENT\n"
"//  PARAM_DIRECT_LIGHT_ONE_STRATEGY or PARAM_DIRECT_LIGHT_ALL_STRATEGY\n"
"//  PARAM_RADIANCE_CLAMP_MAXVALUE\n"
"//  PARAM_AA_SAMPLES\n"
"//  PARAM_DIRECT_LIGHT_SAMPLES\n"
"//  PARAM_DIFFUSE_SAMPLES\n"
"//  PARAM_GLOSSY_SAMPLES\n"
"//  PARAM_SPECULAR_SAMPLES\n"
"//  PARAM_DEPTH_MAX\n"
"//  PARAM_DEPTH_DIFFUSE_MAX\n"
"//  PARAM_DEPTH_GLOSSY_MAX\n"
"//  PARAM_DEPTH_SPECULAR_MAX\n"
"//  PARAM_IMAGE_FILTER_WIDTH\n"
"//  PARAM_LOW_LIGHT_THREASHOLD\n"
"//  PARAM_NEAR_START_LIGHT\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// InitSeed Kernel\n"
"//------------------------------------------------------------------------------\n"
"\n"
"__kernel __attribute__((work_group_size_hint(64, 1, 1))) void InitSeed(\n"
"		uint seedBase,\n"
"		__global GPUTask *tasks) {\n"
"	//if (get_global_id(0) == 0)\n"
"	//	printf(\"sizeof(BSDF) = %dbytes\\n\", sizeof(BSDF));\n"
"	//if (get_global_id(0) == 0)\n"
"	//	printf(\"sizeof(HitPoint) = %dbytes\\n\", sizeof(HitPoint));\n"
"	//if (get_global_id(0) == 0)\n"
"	//	printf(\"sizeof(GPUTask) = %dbytes\\n\", sizeof(GPUTask));\n"
"	//if (get_global_id(0) == 0)\n"
"	//	printf(\"sizeof(SampleResult) = %dbytes\\n\", sizeof(SampleResult));\n"
"\n"
"	const size_t gid = get_global_id(0);\n"
"	if (gid >= PARAM_TASK_COUNT)\n"
"		return;\n"
"\n"
"	// Initialize the task\n"
"	__global GPUTask *task = &tasks[gid];\n"
"\n"
"	// For testing/debugging\n"
"	//MangleMemory((__global unsigned char *)task, sizeof(GPUTask));\n"
"\n"
"	// Initialize random number generator\n"
"	Seed seed;\n"
"	Rnd_Init(seedBase + gid, &seed);\n"
"\n"
"	// Save the seed\n"
"	task->seed.s1 = seed.s1;\n"
"	task->seed.s2 = seed.s2;\n"
"	task->seed.s3 = seed.s3;\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// InitStats Kernel\n"
"//------------------------------------------------------------------------------\n"
"\n"
"__kernel __attribute__((work_group_size_hint(64, 1, 1))) void InitStat(\n"
"		__global GPUTaskStats *taskStats) {\n"
"	const size_t gid = get_global_id(0);\n"
"	if (gid >= PARAM_TASK_COUNT)\n"
"		return;\n"
"\n"
"	__global GPUTaskStats *taskStat = &taskStats[gid];\n"
"	taskStat->raysCount = 0;\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// BiasAdvancePaths Kernel\n"
"//------------------------------------------------------------------------------\n"
"\n"
"typedef struct {\n"
"	uint depth, diffuseDepth, glossyDepth, specularDepth;\n"
"} PathDepthInfo;\n"
"\n"
"void PathDepthInfo_Init(PathDepthInfo *depthInfo, const uint val) {\n"
"	depthInfo->depth = val;\n"
"	depthInfo->diffuseDepth = val;\n"
"	depthInfo->glossyDepth = val;\n"
"	depthInfo->specularDepth = val;\n"
"}\n"
"\n"
"void PathDepthInfo_IncDepths(PathDepthInfo *depthInfo, const BSDFEvent event) {\n"
"	++(depthInfo->depth);\n"
"	if (event & DIFFUSE)\n"
"		++(depthInfo->diffuseDepth);\n"
"	if (event & GLOSSY)\n"
"		++(depthInfo->glossyDepth);\n"
"	if (event & SPECULAR)\n"
"		++(depthInfo->specularDepth);\n"
"}\n"
"\n"
"bool PathDepthInfo_CheckDepths(PathDepthInfo *depthInfo) {\n"
"	return ((depthInfo->depth <= PARAM_DEPTH_MAX) &&\n"
"			(depthInfo->diffuseDepth <= PARAM_DEPTH_DIFFUSE_MAX) &&\n"
"			(depthInfo->glossyDepth <= PARAM_DEPTH_GLOSSY_MAX) &&\n"
"			(depthInfo->specularDepth <= PARAM_DEPTH_SPECULAR_MAX));\n"
"}\n"
"\n"
"void SR_RadianceClamp(__global SampleResult *sampleResult) {\n"
"	// Initialize only Spectrum fields\n"
"\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_0)\n"
"	sampleResult->radiancePerPixelNormalized[0].r = clamp(sampleResult->radiancePerPixelNormalized[0].r, 0.f, PARAM_RADIANCE_CLAMP_MAXVALUE);\n"
"	sampleResult->radiancePerPixelNormalized[0].g = clamp(sampleResult->radiancePerPixelNormalized[0].g, 0.f, PARAM_RADIANCE_CLAMP_MAXVALUE);\n"
"	sampleResult->radiancePerPixelNormalized[0].b = clamp(sampleResult->radiancePerPixelNormalized[0].b, 0.f, PARAM_RADIANCE_CLAMP_MAXVALUE);\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_1)\n"
"	sampleResult->radiancePerPixelNormalized[1].r = clamp(sampleResult->radiancePerPixelNormalized[1].r, 0.f, PARAM_RADIANCE_CLAMP_MAXVALUE);\n"
"	sampleResult->radiancePerPixelNormalized[1].g = clamp(sampleResult->radiancePerPixelNormalized[1].g, 0.f, PARAM_RADIANCE_CLAMP_MAXVALUE);\n"
"	sampleResult->radiancePerPixelNormalized[1].b = clamp(sampleResult->radiancePerPixelNormalized[1].b, 0.f, PARAM_RADIANCE_CLAMP_MAXVALUE);\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_2)\n"
"	sampleResult->radiancePerPixelNormalized[2].r = clamp(sampleResult->radiancePerPixelNormalized[2].r, 0.f, PARAM_RADIANCE_CLAMP_MAXVALUE);\n"
"	sampleResult->radiancePerPixelNormalized[2].g = clamp(sampleResult->radiancePerPixelNormalized[2].g, 0.f, PARAM_RADIANCE_CLAMP_MAXVALUE);\n"
"	sampleResult->radiancePerPixelNormalized[2].b = clamp(sampleResult->radiancePerPixelNormalized[2].b, 0.f, PARAM_RADIANCE_CLAMP_MAXVALUE);\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_3)\n"
"	sampleResult->radiancePerPixelNormalized[3].r = clamp(sampleResult->radiancePerPixelNormalized[3].r, 0.f, PARAM_RADIANCE_CLAMP_MAXVALUE);\n"
"	sampleResult->radiancePerPixelNormalized[3].g = clamp(sampleResult->radiancePerPixelNormalized[3].g, 0.f, PARAM_RADIANCE_CLAMP_MAXVALUE);\n"
"	sampleResult->radiancePerPixelNormalized[3].b = clamp(sampleResult->radiancePerPixelNormalized[3].b, 0.f, PARAM_RADIANCE_CLAMP_MAXVALUE);\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_4)\n"
"	sampleResult->radiancePerPixelNormalized[4].r = clamp(sampleResult->radiancePerPixelNormalized[4].r, 0.f, PARAM_RADIANCE_CLAMP_MAXVALUE);\n"
"	sampleResult->radiancePerPixelNormalized[4].g = clamp(sampleResult->radiancePerPixelNormalized[4].g, 0.f, PARAM_RADIANCE_CLAMP_MAXVALUE);\n"
"	sampleResult->radiancePerPixelNormalized[4].b = clamp(sampleResult->radiancePerPixelNormalized[4].b, 0.f, PARAM_RADIANCE_CLAMP_MAXVALUE);\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_5)\n"
"	sampleResult->radiancePerPixelNormalized[5].r = clamp(sampleResult->radiancePerPixelNormalized[5].r, 0.f, PARAM_RADIANCE_CLAMP_MAXVALUE);\n"
"	sampleResult->radiancePerPixelNormalized[5].g = clamp(sampleResult->radiancePerPixelNormalized[5].g, 0.f, PARAM_RADIANCE_CLAMP_MAXVALUE);\n"
"	sampleResult->radiancePerPixelNormalized[5].b = clamp(sampleResult->radiancePerPixelNormalized[5].b, 0.f, PARAM_RADIANCE_CLAMP_MAXVALUE);\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_6)\n"
"	sampleResult->radiancePerPixelNormalized[6].r = clamp(sampleResult->radiancePerPixelNormalized[6].r, 0.f, PARAM_RADIANCE_CLAMP_MAXVALUE);\n"
"	sampleResult->radiancePerPixelNormalized[6].g = clamp(sampleResult->radiancePerPixelNormalized[6].g, 0.f, PARAM_RADIANCE_CLAMP_MAXVALUE);\n"
"	sampleResult->radiancePerPixelNormalized[6].b = clamp(sampleResult->radiancePerPixelNormalized[6].b, 0.f, PARAM_RADIANCE_CLAMP_MAXVALUE);\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_7)\n"
"	sampleResult->radiancePerPixelNormalized[7].r = clamp(sampleResult->radiancePerPixelNormalized[7].r, 0.f, PARAM_RADIANCE_CLAMP_MAXVALUE);\n"
"	sampleResult->radiancePerPixelNormalized[7].g = clamp(sampleResult->radiancePerPixelNormalized[7].g, 0.f, PARAM_RADIANCE_CLAMP_MAXVALUE);\n"
"	sampleResult->radiancePerPixelNormalized[7].b = clamp(sampleResult->radiancePerPixelNormalized[7].b, 0.f, PARAM_RADIANCE_CLAMP_MAXVALUE);\n"
"#endif\n"
"}\n"
"\n"
"void SampleGrid(Seed *seed, const uint size,\n"
"		const uint ix, const uint iy, float *u0, float *u1) {\n"
"	*u0 = Rnd_FloatValue(seed);\n"
"	*u1 = Rnd_FloatValue(seed);\n"
"\n"
"	if (size > 1) {\n"
"		const float idim = 1.f / size;\n"
"		*u0 = (ix + *u0) * idim;\n"
"		*u1 = (iy + *u1) * idim;\n"
"	}\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"\n"
"void GenerateCameraRay(\n"
"		Seed *seed,\n"
"		__global GPUTask *task,\n"
"		__global SampleResult *sampleResult,\n"
"		__global Camera *camera,\n"
"		__global float *pixelFilterDistribution,\n"
"		const uint sampleX, const uint sampleY, const int sampleIndex,\n"
"		const uint tileStartX, const uint tileStartY, \n"
"		const uint engineFilmWidth, const uint engineFilmHeight,\n"
"		Ray *ray) {\n"
"	//if (get_global_id(0) == 0)\n"
"	//	printf(\"tileSampleIndex: %d (%d, %d)\\n\", sampleIndex, sampleIndex % PARAM_AA_SAMPLES, sampleIndex / PARAM_AA_SAMPLES);\n"
"\n"
"	float u0, u1;\n"
"	SampleGrid(seed, PARAM_AA_SAMPLES,\n"
"			sampleIndex % PARAM_AA_SAMPLES, sampleIndex / PARAM_AA_SAMPLES,\n"
"			&u0, &u1);\n"
"\n"
"	float2 xy;\n"
"	float distPdf;\n"
"	Distribution2D_SampleContinuous(pixelFilterDistribution, u0, u1, &xy, &distPdf);\n"
"\n"
"	const float filmX = sampleX + .5f + (xy.x - .5f) * PARAM_IMAGE_FILTER_WIDTH_X;\n"
"	const float filmY = sampleY + .5f + (xy.y - .5f) * PARAM_IMAGE_FILTER_WIDTH_Y;\n"
"	sampleResult->filmX = filmX;\n"
"	sampleResult->filmY = filmY;\n"
"\n"
"#if defined(PARAM_CAMERA_HAS_DOF)\n"
"	const float dofSampleX = Rnd_FloatValue(seed);\n"
"	const float dofSampleY = Rnd_FloatValue(seed);\n"
"#endif\n"
"\n"
"	Camera_GenerateRay(camera, engineFilmWidth, engineFilmHeight, ray, tileStartX + filmX, tileStartY + filmY\n"
"#if defined(PARAM_CAMERA_HAS_DOF)\n"
"			, dofSampleX, dofSampleY\n"
"#endif\n"
"			);	\n"
"}\n"
"\n"
"#if defined(PARAM_HAS_SKYLIGHT) || defined(PARAM_HAS_INFINITELIGHT) || defined(PARAM_HAS_SUNLIGHT)\n"
"void DirectHitInfiniteLight(\n"
"		const bool firstPathVertex,\n"
"		const BSDFEvent lastBSDFEvent,\n"
"		const BSDFEvent pathBSDFEvent,\n"
"		__global BSDFEvent *lightVisibility,\n"
"		__global float *lightsDistribution,\n"
"#if defined(PARAM_HAS_INFINITELIGHT)\n"
"		__global InfiniteLight *infiniteLight,\n"
"		__global float *infiniteLightDistribution,\n"
"#endif\n"
"#if defined(PARAM_HAS_SUNLIGHT)\n"
"		__global SunLight *sunLight,\n"
"#endif\n"
"#if defined(PARAM_HAS_SKYLIGHT)\n"
"		__global SkyLight *skyLight,\n"
"#endif\n"
"		__global const Spectrum *pathThroughput,\n"
"		const float3 eyeDir, const float lastPdfW,\n"
"		__global SampleResult *sampleResult\n"
"		IMAGEMAPS_PARAM_DECL) {\n"
"	const float3 throughput = VLOAD3F(&pathThroughput->r);\n"
"\n"
"#if defined(PARAM_HAS_INFINITELIGHT)\n"
"	{\n"
"		const uint infiniteLightIndex = PARAM_TRIANGLE_LIGHT_COUNT\n"
"#if defined(PARAM_HAS_SUNLIGHT)\n"
"			+ 1\n"
"#endif\n"
"		;\n"
"\n"
"		if (firstPathVertex || (lightVisibility[infiniteLightIndex] & (pathBSDFEvent & (DIFFUSE | GLOSSY | SPECULAR)))) {\n"
"			float directPdfW;\n"
"			const float3 infiniteLightRadiance = InfiniteLight_GetRadiance(infiniteLight,\n"
"					infiniteLightDistribution, eyeDir, &directPdfW\n"
"					IMAGEMAPS_PARAM);\n"
"			if (!Spectrum_IsBlack(infiniteLightRadiance)) {\n"
"				// MIS between BSDF sampling and direct light sampling\n"
"				const float lightPickProb = Scene_SampleAllLightPdf(lightsDistribution, infiniteLight->lightSceneIndex);\n"
"				const float weight = ((lastBSDFEvent & SPECULAR) ? 1.f : PowerHeuristic(lastPdfW, directPdfW * lightPickProb));\n"
"				const float3 lightRadiance = weight * throughput * infiniteLightRadiance;\n"
"\n"
"				const uint lightID = min(infiniteLight->lightID, PARAM_FILM_RADIANCE_GROUP_COUNT - 1u);\n"
"				AddEmission(firstPathVertex, pathBSDFEvent, lightID, sampleResult, lightRadiance);\n"
"			}\n"
"		}\n"
"	}\n"
"#endif\n"
"#if defined(PARAM_HAS_SKYLIGHT)\n"
"	{\n"
"		const uint skyLightIndex = PARAM_TRIANGLE_LIGHT_COUNT\n"
"#if defined(PARAM_HAS_SUNLIGHT)\n"
"			+ 1\n"
"#endif\n"
"		;\n"
"\n"
"		if (firstPathVertex || (lightVisibility[skyLightIndex] & (pathBSDFEvent & (DIFFUSE | GLOSSY | SPECULAR)))) {\n"
"			float directPdfW;\n"
"			const float3 skyRadiance = SkyLight_GetRadiance(skyLight, eyeDir, &directPdfW);\n"
"			if (!Spectrum_IsBlack(skyRadiance)) {\n"
"				// MIS between BSDF sampling and direct light sampling\n"
"				const float lightPickProb = Scene_SampleAllLightPdf(lightsDistribution, skyLight->lightSceneIndex);\n"
"				const float weight = ((lastBSDFEvent & SPECULAR) ? 1.f : PowerHeuristic(lastPdfW, directPdfW * lightPickProb));\n"
"				const float3 lightRadiance = weight * throughput * skyRadiance;\n"
"\n"
"				const uint lightID = min(skyLight->lightID, PARAM_FILM_RADIANCE_GROUP_COUNT - 1u);\n"
"				AddEmission(firstPathVertex, pathBSDFEvent, lightID, sampleResult, lightRadiance);\n"
"			}\n"
"		}\n"
"	}\n"
"#endif\n"
"#if defined(PARAM_HAS_SUNLIGHT)\n"
"	{\n"
"		const uint sunLightIndex = PARAM_TRIANGLE_LIGHT_COUNT;\n"
"\n"
"		if (firstPathVertex || (lightVisibility[sunLightIndex] & (pathBSDFEvent & (DIFFUSE | GLOSSY | SPECULAR)))) {\n"
"			float directPdfW;\n"
"			const float3 sunRadiance = SunLight_GetRadiance(sunLight, eyeDir, &directPdfW);\n"
"			if (!Spectrum_IsBlack(sunRadiance)) {\n"
"				// MIS between BSDF sampling and direct light sampling\n"
"				const float lightPickProb = Scene_SampleAllLightPdf(lightsDistribution, sunLight->lightSceneIndex);\n"
"				const float weight = ((lastBSDFEvent & SPECULAR) ? 1.f : PowerHeuristic(lastPdfW, directPdfW * lightPickProb));\n"
"				const float3 lightRadiance = weight * throughput * sunRadiance;\n"
"\n"
"				const uint lightID = min(sunLight->lightID, PARAM_FILM_RADIANCE_GROUP_COUNT - 1u);\n"
"				AddEmission(firstPathVertex, pathBSDFEvent, lightID, sampleResult, lightRadiance);\n"
"			}\n"
"		}\n"
"	}\n"
"#endif\n"
"}\n"
"#endif\n"
"\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"void DirectHitFiniteLight(\n"
"		const bool firstPathVertex,\n"
"		const BSDFEvent lastBSDFEvent,\n"
"		const BSDFEvent pathBSDFEvent,\n"
"		__global BSDFEvent *lightVisibility,\n"
"		__global float *lightsDistribution,\n"
"		__global TriangleLight *triLightDefs,\n"
"		__global const Spectrum *pathThroughput, const float distance, __global BSDF *bsdf,\n"
"		const float lastPdfW, __global SampleResult *sampleResult\n"
"		MATERIALS_PARAM_DECL) {\n"
"	if (firstPathVertex || (lightVisibility[bsdf->triangleLightSourceIndex] & (pathBSDFEvent & (DIFFUSE | GLOSSY | SPECULAR)))) {\n"
"		float directPdfA;\n"
"		const float3 emittedRadiance = BSDF_GetEmittedRadiance(bsdf,\n"
"				triLightDefs, &directPdfA\n"
"				MATERIALS_PARAM);\n"
"\n"
"		if (!Spectrum_IsBlack(emittedRadiance)) {\n"
"			// Add emitted radiance\n"
"			float weight = 1.f;\n"
"			if (!(lastBSDFEvent & SPECULAR)) {\n"
"				const float lightPickProb = Scene_SampleAllLightPdf(lightsDistribution,\n"
"						triLightDefs[bsdf->triangleLightSourceIndex].lightSceneIndex);\n"
"				const float directPdfW = PdfAtoW(directPdfA, distance,\n"
"					fabs(dot(VLOAD3F(&bsdf->hitPoint.fixedDir.x), VLOAD3F(&bsdf->hitPoint.shadeN.x))));\n"
"\n"
"				// MIS between BSDF sampling and direct light sampling\n"
"				weight = PowerHeuristic(lastPdfW, directPdfW * lightPickProb);\n"
"			}\n"
"			const float3 lightRadiance = weight * VLOAD3F(&pathThroughput->r) * emittedRadiance;\n"
"\n"
"			const uint lightID =  min(BSDF_GetLightID(bsdf\n"
"					MATERIALS_PARAM), PARAM_FILM_RADIANCE_GROUP_COUNT - 1u);\n"
"			AddEmission(firstPathVertex, pathBSDFEvent, lightID, sampleResult, lightRadiance);\n"
"		}\n"
"	}\n"
"}\n"
"#endif\n"
"\n"
"bool DirectLightSampling(\n"
"		const uint lightIndex,\n"
"		const float lightPickPdf,\n"
"#if defined(PARAM_HAS_INFINITELIGHT) || defined(PARAM_HAS_SKYLIGHT)\n"
"		const float worldCenterX,\n"
"		const float worldCenterY,\n"
"		const float worldCenterZ,\n"
"		const float worldRadius,\n"
"#endif\n"
"#if defined(PARAM_HAS_INFINITELIGHT)\n"
"		__global InfiniteLight *infiniteLight,\n"
"		__global float *infiniteLightDistribution,\n"
"#endif\n"
"#if defined(PARAM_HAS_SUNLIGHT)\n"
"		__global SunLight *sunLight,\n"
"#endif\n"
"#if defined(PARAM_HAS_SKYLIGHT)\n"
"		__global SkyLight *skyLight,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"		__global TriangleLight *triLightDefs,\n"
"		__global HitPoint *directLightHitPoint,\n"
"#endif\n"
"		__global float *lightsDistribution,\n"
"		const float u0, const float u1, const float u2,\n"
"		__global const Spectrum *pathThroughput, __global BSDF *bsdf,\n"
"		Ray *shadowRay, __global Spectrum *radiance, __global uint *ID\n"
"		MATERIALS_PARAM_DECL) {\n"
"	float3 lightRayDir;\n"
"	float distance, directPdfW;\n"
"	float3 lightRadiance;\n"
"	uint lightID;\n"
"\n"
"#if defined(PARAM_HAS_INFINITELIGHT)\n"
"	const uint infiniteLightIndex = PARAM_TRIANGLE_LIGHT_COUNT\n"
"#if defined(PARAM_HAS_SUNLIGHT)\n"
"		+ 1\n"
"#endif\n"
"	;\n"
"\n"
"	if (lightIndex == infiniteLightIndex) {\n"
"		lightRadiance = InfiniteLight_Illuminate(\n"
"			infiniteLight,\n"
"			infiniteLightDistribution,\n"
"			worldCenterX, worldCenterY, worldCenterZ, worldRadius,\n"
"			u0, u1,\n"
"			VLOAD3F(&bsdf->hitPoint.p.x),\n"
"			&lightRayDir, &distance, &directPdfW\n"
"			IMAGEMAPS_PARAM);\n"
"		lightID = infiniteLight->lightID;\n"
"	}\n"
"#endif\n"
"\n"
"#if defined(PARAM_HAS_SKYLIGHT)\n"
"	const uint skyLightIndex = PARAM_TRIANGLE_LIGHT_COUNT\n"
"#if defined(PARAM_HAS_SUNLIGHT)\n"
"		+ 1\n"
"#endif\n"
"	;\n"
"\n"
"	if (lightIndex == skyLightIndex) {\n"
"		lightRadiance = SkyLight_Illuminate(\n"
"			skyLight,\n"
"			worldCenterX, worldCenterY, worldCenterZ, worldRadius,\n"
"			u0, u1,\n"
"			VLOAD3F(&bsdf->hitPoint.p.x),\n"
"			&lightRayDir, &distance, &directPdfW);\n"
"		lightID = skyLight->lightID;\n"
"	}\n"
"#endif\n"
"\n"
"#if defined(PARAM_HAS_SUNLIGHT)\n"
"	const uint sunLightIndex = PARAM_TRIANGLE_LIGHT_COUNT;\n"
"	if (lightIndex == sunLightIndex) {\n"
"		lightRadiance = SunLight_Illuminate(\n"
"			sunLight,\n"
"			u0, u1,\n"
"			&lightRayDir, &distance, &directPdfW);\n"
"		lightID = sunLight->lightID;\n"
"	}\n"
"#endif\n"
"\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"	if (lightIndex < PARAM_TRIANGLE_LIGHT_COUNT) {\n"
"		lightRadiance = TriangleLight_Illuminate(\n"
"			&triLightDefs[lightIndex], directLightHitPoint,\n"
"			VLOAD3F(&bsdf->hitPoint.p.x),\n"
"			u0, u1, u2,\n"
"			&lightRayDir, &distance, &directPdfW\n"
"			MATERIALS_PARAM);\n"
"		lightID = mats[triLightDefs[lightIndex].materialIndex].lightID;\n"
"	}\n"
"#endif\n"
"\n"
"	// Setup the shadow ray\n"
"	const float cosThetaToLight = fabs(dot(lightRayDir, VLOAD3F(&bsdf->hitPoint.shadeN.x)));\n"
"	if (((Spectrum_Y(lightRadiance) * cosThetaToLight / directPdfW) > PARAM_LOW_LIGHT_THREASHOLD) &&\n"
"			(distance > PARAM_NEAR_START_LIGHT)) {\n"
"		BSDFEvent event;\n"
"		float bsdfPdfW;\n"
"		const float3 bsdfEval = BSDF_Evaluate(bsdf,\n"
"				lightRayDir, &event, &bsdfPdfW\n"
"				MATERIALS_PARAM);\n"
"\n"
"		if (!Spectrum_IsBlack(bsdfEval)) {\n"
"			const float directLightSamplingPdfW = directPdfW * lightPickPdf;\n"
"			const float factor = cosThetaToLight / directLightSamplingPdfW;\n"
"\n"
"			// MIS between direct light sampling and BSDF sampling\n"
"			const float weight = PowerHeuristic(directLightSamplingPdfW, bsdfPdfW);\n"
"\n"
"			VSTORE3F((weight * factor) * VLOAD3F(&pathThroughput->r) * bsdfEval * lightRadiance, &radiance->r);\n"
"			*ID = min(lightID, PARAM_FILM_RADIANCE_GROUP_COUNT - 1u);\n"
"\n"
"			// Setup the shadow ray\n"
"			const float3 hitPoint = VLOAD3F(&bsdf->hitPoint.p.x);\n"
"			const float epsilon = fmax(MachineEpsilon_E_Float3(hitPoint), MachineEpsilon_E(distance));\n"
"\n"
"			Ray_Init4_Private(shadowRay, hitPoint, lightRayDir,\n"
"				epsilon,\n"
"				distance - epsilon);\n"
"\n"
"			return true;\n"
"		}\n"
"	}\n"
"\n"
"	return false;\n"
"}\n"
"\n"
"bool DirectLightSampling_ONE(\n"
"		const bool firstPathVertex,\n"
"		Seed *seed,\n"
"#if defined(PARAM_HAS_INFINITELIGHT) || defined(PARAM_HAS_SKYLIGHT)\n"
"		const float worldCenterX,\n"
"		const float worldCenterY,\n"
"		const float worldCenterZ,\n"
"		const float worldRadius,\n"
"#endif\n"
"#if defined(PARAM_HAS_INFINITELIGHT)\n"
"		__global InfiniteLight *infiniteLight,\n"
"		__global float *infiniteLightDistribution,\n"
"#endif\n"
"#if defined(PARAM_HAS_SUNLIGHT)\n"
"		__global SunLight *sunLight,\n"
"#endif\n"
"#if defined(PARAM_HAS_SKYLIGHT)\n"
"		__global SkyLight *skyLight,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"		__global TriangleLight *triLightDefs,\n"
"		__global HitPoint *directLightHitPoint,\n"
"#endif\n"
"		__global float *lightsDistribution,\n"
"		__global const Spectrum *pathThroughput, __global BSDF *bsdf,\n"
"		__global SampleResult *sampleResult,\n"
"		Ray *shadowRay, __global Spectrum *radiance, __global uint *ID\n"
"		MATERIALS_PARAM_DECL) {\n"
"	// Pick a light source to sample\n"
"	float lightPickPdf;\n"
"	const uint lightIndex = Scene_SampleAllLights(lightsDistribution, Rnd_FloatValue(seed), &lightPickPdf);\n"
"\n"
"	const bool illuminated = DirectLightSampling(\n"
"		lightIndex,\n"
"		lightPickPdf,\n"
"#if defined(PARAM_HAS_INFINITELIGHT) || defined(PARAM_HAS_SKYLIGHT)\n"
"		worldCenterX,\n"
"		worldCenterY,\n"
"		worldCenterZ,\n"
"		worldRadius,\n"
"#endif\n"
"#if defined(PARAM_HAS_INFINITELIGHT)\n"
"		infiniteLight,\n"
"		infiniteLightDistribution,\n"
"#endif\n"
"#if defined(PARAM_HAS_SUNLIGHT)\n"
"		sunLight,\n"
"#endif\n"
"#if defined(PARAM_HAS_SKYLIGHT)\n"
"		skyLight,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"		triLightDefs,\n"
"		directLightHitPoint,\n"
"#endif\n"
"		lightsDistribution,\n"
"		Rnd_FloatValue(seed), Rnd_FloatValue(seed), Rnd_FloatValue(seed),\n"
"		pathThroughput, bsdf,\n"
"		shadowRay, radiance, ID\n"
"		MATERIALS_PARAM);\n"
"\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_SHADOW_MASK)\n"
"	if (firstPathVertex && !illuminated)\n"
"		sampleResult->directShadowMask += 1.f;\n"
"#endif\n"
"\n"
"	return illuminated;\n"
"}\n"
"\n"
"#if defined(PARAM_DIRECT_LIGHT_ALL_STRATEGY)\n"
"bool DirectLightSampling_ALL(\n"
"		__global uint *currentLightIndex,\n"
"		__global uint *currentLightSampleIndex,\n"
"		__global int *lightSamples,\n"
"		Seed *seed,\n"
"#if defined(PARAM_HAS_INFINITELIGHT) || defined(PARAM_HAS_SKYLIGHT)\n"
"		const float worldCenterX,\n"
"		const float worldCenterY,\n"
"		const float worldCenterZ,\n"
"		const float worldRadius,\n"
"#endif\n"
"#if defined(PARAM_HAS_INFINITELIGHT)\n"
"		__global InfiniteLight *infiniteLight,\n"
"		__global float *infiniteLightDistribution,\n"
"#endif\n"
"#if defined(PARAM_HAS_SUNLIGHT)\n"
"		__global SunLight *sunLight,\n"
"#endif\n"
"#if defined(PARAM_HAS_SKYLIGHT)\n"
"		__global SkyLight *skyLight,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"		__global TriangleLight *triLightDefs,\n"
"		__global HitPoint *directLightHitPoint,\n"
"#endif\n"
"		__global float *lightsDistribution,\n"
"		__global const Spectrum *pathThroughput, __global BSDF *bsdf,\n"
"		__global SampleResult *sampleResult,\n"
"		Ray *shadowRay, __global Spectrum *radiance, __global uint *ID\n"
"		MATERIALS_PARAM_DECL) {\n"
"	for (; *currentLightIndex < PARAM_LIGHT_COUNT; ++(*currentLightIndex)) {\n"
"		const int lightSamplesCount = lightSamples[*currentLightIndex];\n"
"		const uint sampleCount = (lightSamplesCount < 0) ? PARAM_DIRECT_LIGHT_SAMPLES : (uint)lightSamplesCount;\n"
"		const uint sampleCount2 = sampleCount * sampleCount;\n"
"\n"
"		for (; *currentLightSampleIndex < sampleCount2; ++(*currentLightSampleIndex)) {\n"
"			//if (get_global_id(0) == 0)\n"
"			//	printf(\"DirectLightSampling_ALL() ==> currentLightIndex: %d  currentLightSampleIndex: %d\\n\", *currentLightIndex, *currentLightSampleIndex);\n"
"\n"
"			float u0, u1;\n"
"			SampleGrid(seed, sampleCount,\n"
"					(*currentLightSampleIndex) % sampleCount, (*currentLightSampleIndex) / sampleCount,\n"
"					&u0, &u1);\n"
"\n"
"			const float scaleFactor = 1.f / sampleCount2;\n"
"			const bool illuminated = DirectLightSampling(\n"
"				*currentLightIndex,\n"
"				1.f,\n"
"#if defined(PARAM_HAS_INFINITELIGHT) || defined(PARAM_HAS_SKYLIGHT)\n"
"				worldCenterX,\n"
"				worldCenterY,\n"
"				worldCenterZ,\n"
"				worldRadius,\n"
"#endif\n"
"#if defined(PARAM_HAS_INFINITELIGHT)\n"
"				infiniteLight,\n"
"				infiniteLightDistribution,\n"
"#endif\n"
"#if defined(PARAM_HAS_SUNLIGHT)\n"
"				sunLight,\n"
"#endif\n"
"#if defined(PARAM_HAS_SKYLIGHT)\n"
"				skyLight,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"				triLightDefs,\n"
"				directLightHitPoint,\n"
"#endif\n"
"				lightsDistribution,\n"
"				u0, u1, Rnd_FloatValue(seed),\n"
"				pathThroughput, bsdf,\n"
"				shadowRay, radiance, ID\n"
"				MATERIALS_PARAM);\n"
"\n"
"			if (illuminated) {\n"
"				VSTORE3F(scaleFactor * VLOAD3F(&radiance->r), &radiance->r);\n"
"				return true;\n"
"			}\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_SHADOW_MASK)\n"
"			else {\n"
"				sampleResult->directShadowMask += scaleFactor;\n"
"			}\n"
"#endif\n"
"		}\n"
"\n"
"		*currentLightSampleIndex = 0;\n"
"	}\n"
"\n"
"	return false;\n"
"}\n"
"#endif\n"
"\n"
"__kernel __attribute__((work_group_size_hint(64, 1, 1))) void RenderSample(\n"
"		const uint tileStartX,\n"
"		const uint tileStartY,\n"
"		const int tileSampleIndex,\n"
"		const uint engineFilmWidth, const uint engineFilmHeight,\n"
"		__global GPUTask *tasks,\n"
"		__global GPUTaskDirectLight *tasksDirectLight,\n"
"		__global GPUTaskPathVertexN *tasksPathVertexN,\n"
"		__global GPUTaskStats *taskStats,\n"
"		__global SampleResult *taskResults,\n"
"		__global float *pixelFilterDistribution,\n"
"		__global int *lightSamples,\n"
"		__global BSDFEvent *lightVisibility,\n"
"		__global int *materialSamples,\n"
"		// Film parameters\n"
"		const uint filmWidth, const uint filmHeight\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_0)\n"
"		, __global float *filmRadianceGroup0\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_1)\n"
"		, __global float *filmRadianceGroup1\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_2)\n"
"		, __global float *filmRadianceGroup2\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_3)\n"
"		, __global float *filmRadianceGroup3\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_4)\n"
"		, __global float *filmRadianceGroup4\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_5)\n"
"		, __global float *filmRadianceGroup5\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_6)\n"
"		, __global float *filmRadianceGroup6\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_7)\n"
"		, __global float *filmRadianceGroup7\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_ALPHA)\n"
"		, __global float *filmAlpha\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DEPTH)\n"
"		, __global float *filmDepth\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_POSITION)\n"
"		, __global float *filmPosition\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_GEOMETRY_NORMAL)\n"
"		, __global float *filmGeometryNormal\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_SHADING_NORMAL)\n"
"		, __global float *filmShadingNormal\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_MATERIAL_ID)\n"
"		, __global uint *filmMaterialID\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_DIFFUSE)\n"
"		, __global float *filmDirectDiffuse\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_GLOSSY)\n"
"		, __global float *filmDirectGlossy\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_EMISSION)\n"
"		, __global float *filmEmission\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_DIFFUSE)\n"
"		, __global float *filmIndirectDiffuse\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_GLOSSY)\n"
"		, __global float *filmIndirectGlossy\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SPECULAR)\n"
"		, __global float *filmIndirectSpecular\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_MATERIAL_ID_MASK)\n"
"		, __global float *filmMaterialIDMask\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_SHADOW_MASK)\n"
"		, __global float *filmDirectShadowMask\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SHADOW_MASK)\n"
"		, __global float *filmIndirectShadowMask\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_UV)\n"
"		, __global float *filmUV\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_RAYCOUNT)\n"
"		, __global float *filmRayCount\n"
"#endif\n"
"		,\n"
"		// Scene parameters\n"
"		const float worldCenterX,\n"
"		const float worldCenterY,\n"
"		const float worldCenterZ,\n"
"		const float worldRadius,\n"
"		__global Material *mats,\n"
"		__global Texture *texs,\n"
"		__global uint *meshMats,\n"
"		__global Mesh *meshDescs,\n"
"		__global Point *vertices,\n"
"#if defined(PARAM_HAS_NORMALS_BUFFER)\n"
"		__global Vector *vertNormals,\n"
"#endif\n"
"#if defined(PARAM_HAS_UVS_BUFFER)\n"
"		__global UV *vertUVs,\n"
"#endif\n"
"#if defined(PARAM_HAS_COLS_BUFFER)\n"
"		__global Spectrum *vertCols,\n"
"#endif\n"
"#if defined(PARAM_HAS_ALPHAS_BUFFER)\n"
"		__global float *vertAlphas,\n"
"#endif\n"
"		__global Triangle *triangles,\n"
"		__global Camera *camera,\n"
"		__global float *lightsDistribution\n"
"#if defined(PARAM_HAS_INFINITELIGHT)\n"
"		, __global InfiniteLight *infiniteLight\n"
"		, __global float *infiniteLightDistribution\n"
"#endif\n"
"#if defined(PARAM_HAS_SUNLIGHT)\n"
"		, __global SunLight *sunLight\n"
"#endif\n"
"#if defined(PARAM_HAS_SKYLIGHT)\n"
"		, __global SkyLight *skyLight\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"		, __global TriangleLight *triLightDefs\n"
"		, __global uint *meshTriLightDefsOffset\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_0)\n"
"		, __global ImageMap *imageMapDescs, __global float *imageMapBuff0\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_1)\n"
"		, __global float *imageMapBuff1\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_2)\n"
"		, __global float *imageMapBuff2\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_3)\n"
"		, __global float *imageMapBuff3\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_4)\n"
"		, __global float *imageMapBuff4\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_5)\n"
"		, __global float *imageMapBuff5\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_6)\n"
"		, __global float *imageMapBuff6\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_7)\n"
"		, __global float *imageMapBuff7\n"
"#endif\n"
"		ACCELERATOR_INTERSECT_PARAM_DECL\n"
"		) {\n"
"	const size_t gid = get_global_id(0);\n"
"\n"
"#if defined(PARAM_TILE_PROGRESSIVE_REFINEMENT)\n"
"	const uint sampleIndex = tileSampleIndex;\n"
"	const uint samplePixelX = gid % PARAM_TILE_SIZE;\n"
"	const uint samplePixelY = gid / PARAM_TILE_SIZE;\n"
"\n"
"	if ((gid >= PARAM_TILE_SIZE * PARAM_TILE_SIZE) ||\n"
"			(tileStartX + samplePixelX >= engineFilmWidth) ||\n"
"			(tileStartY + samplePixelY >= engineFilmHeight))\n"
"		return;\n"
"#else\n"
"	const uint sampleIndex = gid % (PARAM_AA_SAMPLES * PARAM_AA_SAMPLES);\n"
"	const uint samplePixelIndex = gid / (PARAM_AA_SAMPLES * PARAM_AA_SAMPLES);\n"
"	const uint samplePixelX = samplePixelIndex % PARAM_TILE_SIZE;\n"
"	const uint samplePixelY = samplePixelIndex / PARAM_TILE_SIZE;\n"
"\n"
"	if ((gid >= PARAM_TILE_SIZE * PARAM_TILE_SIZE * PARAM_AA_SAMPLES * PARAM_AA_SAMPLES) ||\n"
"			(tileStartX + samplePixelX >= engineFilmWidth) ||\n"
"			(tileStartY + samplePixelY >= engineFilmHeight))\n"
"		return;\n"
"#endif\n"
"\n"
"	__global GPUTask *task = &tasks[gid];\n"
"	__global GPUTaskDirectLight *taskDirectLight = &tasksDirectLight[gid];\n"
"	__global GPUTaskPathVertexN *taskPathVertexN = &tasksPathVertexN[gid];\n"
"	__global GPUTaskStats *taskStat = &taskStats[gid];\n"
"\n"
"	//--------------------------------------------------------------------------\n"
"	// Initialize image maps page pointer table\n"
"	//--------------------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_HAS_IMAGEMAPS)\n"
"	__global float *imageMapBuff[PARAM_IMAGEMAPS_COUNT];\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_0)\n"
"	imageMapBuff[0] = imageMapBuff0;\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_1)\n"
"	imageMapBuff[1] = imageMapBuff1;\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_2)\n"
"	imageMapBuff[2] = imageMapBuff2;\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_3)\n"
"	imageMapBuff[3] = imageMapBuff3;\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_4)\n"
"	imageMapBuff[4] = imageMapBuff4;\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_5)\n"
"	imageMapBuff[5] = imageMapBuff5;\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_6)\n"
"	imageMapBuff[6] = imageMapBuff6;\n"
"#endif\n"
"#if defined(PARAM_IMAGEMAPS_PAGE_7)\n"
"	imageMapBuff[7] = imageMapBuff7;\n"
"#endif\n"
"#endif\n"
"\n"
"	//--------------------------------------------------------------------------\n"
"	// Initialize the first ray\n"
"	//--------------------------------------------------------------------------\n"
"\n"
"	// Read the seed\n"
"	Seed seed;\n"
"	seed.s1 = task->seed.s1;\n"
"	seed.s2 = task->seed.s2;\n"
"	seed.s3 = task->seed.s3;\n"
"\n"
"	__global SampleResult *sampleResult = &taskResults[gid];\n"
"	SampleResult_Init(sampleResult);\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_SHADOW_MASK)\n"
"	sampleResult->directShadowMask = 0.f;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SHADOW_MASK)\n"
"	sampleResult->indirectShadowMask = 0.f;\n"
"#endif\n"
"\n"
"	Ray ray;\n"
"	RayHit rayHit;\n"
"	GenerateCameraRay(&seed, task, sampleResult,\n"
"			camera, pixelFilterDistribution,\n"
"			samplePixelX, samplePixelY, sampleIndex,\n"
"			tileStartX, tileStartY, \n"
"			engineFilmWidth, engineFilmHeight, &ray);\n"
"\n"
"	//--------------------------------------------------------------------------\n"
"	// Render a sample\n"
"	//--------------------------------------------------------------------------\n"
"\n"
"	taskPathVertexN->vertex1SampleComponent = DIFFUSE;\n"
"	taskPathVertexN->vertex1SampleIndex = 0;\n"
"\n"
"	uint tracedRaysCount = taskStat->raysCount;\n"
"	uint pathState = PATH_VERTEX_1 | NEXT_VERTEX_TRACE_RAY;\n"
"	PathDepthInfo depthInfo;\n"
"	PathDepthInfo_Init(&depthInfo, 0);\n"
"	float lastPdfW = 1.f;\n"
"	BSDFEvent pathBSDFEvent = NONE;\n"
"	BSDFEvent lastBSDFEvent = SPECULAR;\n"
"\n"
"	__global BSDF *currentBSDF = &task->bsdfPathVertex1;\n"
"	__global Spectrum *currentThroughput = &task->throughputPathVertex1;\n"
"	VSTORE3F(WHITE, &task->throughputPathVertex1.r);\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"	// This is a bit tricky. I store the passThroughEvent in the BSDF\n"
"	// before of the initialization because it can be used during the\n"
"	// tracing of next path vertex ray.\n"
"\n"
"	task->bsdfPathVertex1.hitPoint.passThroughEvent = Rnd_FloatValue(&seed);\n"
"#endif\n"
"\n"
"	//if (get_global_id(0) == 0) {\n"
"	//	printf(\"============================================================\\n\");\n"
"	//	printf(\"== Begin loop\\n\");\n"
"	//	printf(\"==\\n\");\n"
"	//	printf(\"== task->bsdfPathVertex1: %x\\n\", &task->bsdfPathVertex1);\n"
"	//	printf(\"== taskDirectLight->directLightBSDF: %x\\n\", &taskDirectLight->directLightBSDF);\n"
"	//	printf(\"== taskPathVertexN->bsdfPathVertexN: %x\\n\", &taskPathVertexN->bsdfPathVertexN);\n"
"	//	printf(\"============================================================\\n\");\n"
"	//}\n"
"\n"
"	while (!(pathState & DONE)) {\n"
"		//if (get_global_id(0) == 0)\n"
"		//	printf(\"Depth: %d  [pathState: %d|%d][currentBSDF: %x][currentThroughput: %x]\\n\",\n"
"		//			depthInfo.depth, pathState >> 16, pathState & LOW_STATE_MASK, currentBSDF, currentThroughput);\n"
"\n"
"		//----------------------------------------------------------------------\n"
"		// Ray trace step\n"
"		//----------------------------------------------------------------------\n"
"\n"
"		Accelerator_Intersect(&ray, &rayHit\n"
"			ACCELERATOR_INTERSECT_PARAM);\n"
"		++tracedRaysCount;\n"
"\n"
"		if (rayHit.meshIndex != NULL_INDEX) {\n"
"			// Something was hit, initialize the BSDF\n"
"			BSDF_Init(currentBSDF,\n"
"					meshDescs,\n"
"					meshMats,\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"					meshTriLightDefsOffset,\n"
"#endif\n"
"					vertices,\n"
"#if defined(PARAM_HAS_NORMALS_BUFFER)\n"
"					vertNormals,\n"
"#endif\n"
"#if defined(PARAM_HAS_UVS_BUFFER)\n"
"					vertUVs,\n"
"#endif\n"
"#if defined(PARAM_HAS_COLS_BUFFER)\n"
"					vertCols,\n"
"#endif\n"
"#if defined(PARAM_HAS_ALPHAS_BUFFER)\n"
"					vertAlphas,\n"
"#endif\n"
"					triangles, &ray, &rayHit\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"					, currentBSDF->hitPoint.passThroughEvent\n"
"#endif\n"
"#if defined(PARAM_HAS_BUMPMAPS) || defined(PARAM_HAS_NORMALMAPS)\n"
"					MATERIALS_PARAM\n"
"#endif\n"
"					);\n"
"\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"			const float3 passThroughTrans = BSDF_GetPassThroughTransparency(currentBSDF\n"
"					MATERIALS_PARAM);\n"
"			if (!Spectrum_IsBlack(passThroughTrans)) {\n"
"				const float3 pathThroughput = VLOAD3F(&currentThroughput->r) * passThroughTrans;\n"
"				VSTORE3F(pathThroughput, &currentThroughput->r);\n"
"\n"
"				// It is a pass through point, continue to trace the ray\n"
"				ray.mint = rayHit.t + MachineEpsilon_E(rayHit.t);\n"
"\n"
"				continue;\n"
"			}\n"
"#endif\n"
"		}\n"
"\n"
"		//----------------------------------------------------------------------\n"
"		// Advance the finite state machine step\n"
"		//----------------------------------------------------------------------\n"
"\n"
"		//----------------------------------------------------------------------\n"
"		// Evaluation of the finite state machine.\n"
"		//\n"
"		// From: * | NEXT_VERTEX_TRACE_RAY\n"
"		// To: BREAK or\n"
"		//     (* | DIRECT_LIGHT_GENERATE_RAY)\n"
"		//     (PATH_VERTEX_N | NEXT_GENERATE_TRACE_RAY)\n"
"		//----------------------------------------------------------------------\n"
"\n"
"		if (pathState & NEXT_VERTEX_TRACE_RAY) {\n"
"			const bool firstPathVertex = (pathState & PATH_VERTEX_1);\n"
"\n"
"			if (rayHit.meshIndex != NULL_INDEX) {\n"
"				//--------------------------------------------------------------\n"
"				// Something was hit\n"
"				//--------------------------------------------------------------\n"
"\n"
"				if (firstPathVertex) {\n"
"					// Save the path first vertex information\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_ALPHA)\n"
"					sampleResult->alpha = 1.f;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DEPTH)\n"
"					sampleResult->depth = rayHit.t;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_POSITION)\n"
"					sampleResult->position = task->bsdfPathVertex1.hitPoint.p;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_GEOMETRY_NORMAL)\n"
"					sampleResult->geometryNormal = task->bsdfPathVertex1.hitPoint.geometryN;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_SHADING_NORMAL)\n"
"					sampleResult->shadingNormal = task->bsdfPathVertex1.hitPoint.shadeN;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_MATERIAL_ID)\n"
"					sampleResult->materialID = BSDF_GetMaterialID(&task->bsdfPathVertex1\n"
"						MATERIALS_PARAM);\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_UV)\n"
"					sampleResult->uv = task->bsdfPathVertex1.hitPoint.uv;\n"
"#endif\n"
"				}\n"
"\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"				// Check if it is a light source (note: I can hit only triangle area light sources)\n"
"				if (BSDF_IsLightSource(currentBSDF) && (rayHit.t > PARAM_NEAR_START_LIGHT)) {\n"
"					DirectHitFiniteLight(firstPathVertex, lastBSDFEvent,\n"
"							pathBSDFEvent, lightVisibility, lightsDistribution,\n"
"							triLightDefs, currentThroughput,\n"
"							rayHit.t, currentBSDF, lastPdfW,\n"
"							sampleResult\n"
"							MATERIALS_PARAM);\n"
"				}\n"
"#endif\n"
"\n"
"				// Before Direct Lighting in order to have a correct MIS\n"
"				if (PathDepthInfo_CheckDepths(&depthInfo)) {\n"
"#if defined(PARAM_DIRECT_LIGHT_ALL_STRATEGY)\n"
"					taskDirectLight->lightIndex = 0;\n"
"					taskDirectLight->lightSampleIndex = 0;\n"
"#endif\n"
"					pathState = (pathState & HIGH_STATE_MASK) | DIRECT_LIGHT_GENERATE_RAY;\n"
"				} else {\n"
"					pathState = firstPathVertex ? DONE :\n"
"						(PATH_VERTEX_1 | NEXT_VERTEX_GENERATE_RAY);\n"
"				}\n"
"			} else {\n"
"				//--------------------------------------------------------------\n"
"				// Nothing was hit, add environmental lights radiance\n"
"				//--------------------------------------------------------------\n"
"\n"
"#if defined(PARAM_HAS_SKYLIGHT) || defined(PARAM_HAS_INFINITELIGHT) || defined(PARAM_HAS_SUNLIGHT)\n"
"				const float3 rayDir = (float3)(ray.d.x, ray.d.y, ray.d.z);\n"
"				DirectHitInfiniteLight(\n"
"						firstPathVertex,\n"
"						lastBSDFEvent,\n"
"						pathBSDFEvent,\n"
"						lightVisibility, \n"
"						lightsDistribution,\n"
"#if defined(PARAM_HAS_INFINITELIGHT)\n"
"						infiniteLight,\n"
"						infiniteLightDistribution,\n"
"#endif\n"
"#if defined(PARAM_HAS_SUNLIGHT)\n"
"						sunLight,\n"
"#endif\n"
"#if defined(PARAM_HAS_SKYLIGHT)\n"
"						skyLight,\n"
"#endif\n"
"						currentThroughput,\n"
"						-rayDir, lastPdfW,\n"
"						sampleResult\n"
"						IMAGEMAPS_PARAM);\n"
"#endif\n"
"\n"
"				if (firstPathVertex) {\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_ALPHA)\n"
"					sampleResult->alpha = 0.f;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DEPTH)\n"
"					sampleResult->depth = INFINITY;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_POSITION)\n"
"					sampleResult->position.x = INFINITY;\n"
"					sampleResult->position.y = INFINITY;\n"
"					sampleResult->position.z = INFINITY;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_GEOMETRY_NORMAL)\n"
"					sampleResult->geometryNormal.x = INFINITY;\n"
"					sampleResult->geometryNormal.y = INFINITY;\n"
"					sampleResult->geometryNormal.z = INFINITY;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_SHADING_NORMAL)\n"
"					sampleResult->shadingNormal.x = INFINITY;\n"
"					sampleResult->shadingNormal.y = INFINITY;\n"
"					sampleResult->shadingNormal.z = INFINITY;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_MATERIAL_ID)\n"
"					sampleResult->materialID = NULL_INDEX;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_UV)\n"
"					sampleResult->uv.u = INFINITY;\n"
"					sampleResult->uv.v = INFINITY;\n"
"#endif\n"
"				}\n"
"\n"
"				pathState = firstPathVertex ? DONE : (PATH_VERTEX_1 | NEXT_VERTEX_GENERATE_RAY);\n"
"			}\n"
"		}\n"
"\n"
"		//----------------------------------------------------------------------\n"
"		// Evaluation of the finite state machine.\n"
"		//\n"
"		// From: * | DIRECT_LIGHT_TRACE_RAY\n"
"		// To: (* | NEXT_VERTEX_GENERATE_RAY) or\n"
"		//     (* | DIRECT_LIGHT_GENERATE_RAY)\n"
"		//----------------------------------------------------------------------\n"
"\n"
"		if (pathState & DIRECT_LIGHT_TRACE_RAY) {\n"
"			const bool firstPathVertex = (pathState & PATH_VERTEX_1);\n"
"\n"
"			if (rayHit.meshIndex == NULL_INDEX) {\n"
"				//--------------------------------------------------------------\n"
"				// Nothing was hit, the light source is visible\n"
"				//--------------------------------------------------------------\n"
"\n"
"				// currentThroughput contains the shadow ray throughput\n"
"				const float3 lightRadiance = VLOAD3F(&currentThroughput->r) * VLOAD3F(&taskDirectLight->lightRadiance.r);\n"
"				const uint lightID = taskDirectLight->lightID;\n"
"				VADD3F(&sampleResult->radiancePerPixelNormalized[lightID].r, lightRadiance);\n"
"\n"
"				//if (get_global_id(0) == 0)\n"
"				//	printf(\"DIRECT_LIGHT_TRACE_RAY => lightRadiance: %f %f %f [%d]\\n\", lightRadiance.s0, lightRadiance.s1, lightRadiance.s2, lightID);\n"
"\n"
"				if (firstPathVertex) {\n"
"					if (BSDF_GetEventTypes(&task->bsdfPathVertex1\n"
"							MATERIALS_PARAM) & DIFFUSE) {\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_DIFFUSE)\n"
"						VADD3F(&sampleResult->directDiffuse.r, lightRadiance);\n"
"#endif\n"
"					} else {\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_GLOSSY)\n"
"						VADD3F(&sampleResult->directGlossy.r, lightRadiance);\n"
"#endif\n"
"					}\n"
"				} else {\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SHADOW_MASK)\n"
"					sample->result.indirectShadowMask = 0.f;\n"
"#endif\n"
"\n"
"					if (pathBSDFEvent & DIFFUSE) {\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_DIFFUSE)\n"
"						VADD3F(&sample->result.indirectDiffuse.r, lightRadiance);\n"
"#endif\n"
"					} else if (pathBSDFEvent & GLOSSY) {\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_GLOSSY)\n"
"						VADD3F(&sample->result.indirectGlossy.r, lightRadiance);\n"
"#endif\n"
"					} else if (pathBSDFEvent & SPECULAR) {\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SPECULAR)\n"
"						VADD3F(&sample->result.indirectSpecular.r, lightRadiance);\n"
"#endif\n"
"					}\n"
"				}\n"
"			}\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_SHADOW_MASK)\n"
"			else {\n"
"				if (firstPathVertex) {\n"
"					const int lightSamplesCount = lightSamples[*currentLightIndex];\n"
"					const uint sampleCount = (lightSamplesCount < 0) ? PARAM_DIRECT_LIGHT_SAMPLES : (uint)lightSamplesCount;\n"
"\n"
"					sampleResult->directShadowMask += 1.f / (sampleCount * sampleCount);\n"
"				}\n"
"			}\n"
"#endif\n"
"\n"
"#if defined(PARAM_DIRECT_LIGHT_ALL_STRATEGY)\n"
"			if (firstPathVertex) {\n"
"				const uint lightIndex = taskDirectLight->lightIndex;\n"
"				if (lightIndex <= PARAM_LIGHT_COUNT) {\n"
"					++(taskDirectLight->lightSampleIndex);\n"
"					pathState = PATH_VERTEX_1 | DIRECT_LIGHT_GENERATE_RAY;\n"
"				} else {\n"
"					// Move to the next path vertex\n"
"					pathState = PATH_VERTEX_1 | NEXT_VERTEX_GENERATE_RAY;\n"
"				}\n"
"			} else {\n"
"				// Move to the next path vertex\n"
"				pathState = PATH_VERTEX_N | NEXT_VERTEX_GENERATE_RAY;\n"
"			}\n"
"#else\n"
"			// Move to the next path vertex\n"
"			pathState = (pathState & HIGH_STATE_MASK) | NEXT_VERTEX_GENERATE_RAY;\n"
"#endif\n"
"		}\n"
"\n"
"		//----------------------------------------------------------------------\n"
"		// Evaluation of the finite state machine.\n"
"		//\n"
"		// From: * | DIRECT_LIGHT_GENERATE_RAY\n"
"		// To: (* | NEXT_VERTEX_GENERATE_RAY) or \n"
"		//     (* | DIRECT_LIGHT_TRACE_RAY[continue])\n"
"		//     (* | NEXT_VERTEX_GENERATE_RAY)\n"
"		//----------------------------------------------------------------------\n"
"\n"
"		if (pathState & DIRECT_LIGHT_GENERATE_RAY) {\n"
"			const bool firstPathVertex = (pathState & PATH_VERTEX_1);\n"
"\n"
"			if (BSDF_IsDelta(firstPathVertex ? &task->bsdfPathVertex1 : &taskPathVertexN->bsdfPathVertexN\n"
"				MATERIALS_PARAM)) {\n"
"				// Move to the next path vertex\n"
"				pathState = (pathState & HIGH_STATE_MASK) | NEXT_VERTEX_GENERATE_RAY;\n"
"			} else {\n"
"				const bool illuminated =\n"
"#if defined(PARAM_DIRECT_LIGHT_ALL_STRATEGY)\n"
"				(!firstPathVertex) ?\n"
"#endif\n"
"					DirectLightSampling_ONE(\n"
"						firstPathVertex,\n"
"						&seed,\n"
"#if defined(PARAM_HAS_INFINITELIGHT) || defined(PARAM_HAS_SKYLIGHT)\n"
"						worldCenterX, worldCenterY, worldCenterZ, worldRadius,\n"
"#endif\n"
"#if defined(PARAM_HAS_INFINITELIGHT)\n"
"						infiniteLight,\n"
"						infiniteLightDistribution,\n"
"#endif\n"
"#if defined(PARAM_HAS_SUNLIGHT)\n"
"						sunLight,\n"
"#endif\n"
"#if defined(PARAM_HAS_SKYLIGHT)\n"
"						skyLight,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"						triLightDefs,\n"
"						&taskDirectLight->directLightHitPoint,\n"
"#endif\n"
"						lightsDistribution,\n"
"						firstPathVertex ? &task->throughputPathVertex1 : &taskPathVertexN->throughputPathVertexN,\n"
"						firstPathVertex ? &task->bsdfPathVertex1 : &taskPathVertexN->bsdfPathVertexN,\n"
"						sampleResult,\n"
"						&ray, &taskDirectLight->lightRadiance, &taskDirectLight->lightID\n"
"						MATERIALS_PARAM)\n"
"#if defined(PARAM_DIRECT_LIGHT_ALL_STRATEGY)\n"
"				: DirectLightSampling_ALL(\n"
"						&taskDirectLight->lightIndex,\n"
"						&taskDirectLight->lightSampleIndex,\n"
"						lightSamples,\n"
"						&seed,\n"
"#if defined(PARAM_HAS_INFINITELIGHT) || defined(PARAM_HAS_SKYLIGHT)\n"
"						worldCenterX, worldCenterY, worldCenterZ, worldRadius,\n"
"#endif\n"
"#if defined(PARAM_HAS_INFINITELIGHT)\n"
"						infiniteLight,\n"
"						infiniteLightDistribution,\n"
"#endif\n"
"#if defined(PARAM_HAS_SUNLIGHT)\n"
"						sunLight,\n"
"#endif\n"
"#if defined(PARAM_HAS_SKYLIGHT)\n"
"						skyLight,\n"
"#endif\n"
"#if (PARAM_TRIANGLE_LIGHT_COUNT > 0)\n"
"						triLightDefs,\n"
"						&taskDirectLight->directLightHitPoint,\n"
"#endif\n"
"						lightsDistribution,\n"
"						&task->throughputPathVertex1, &task->bsdfPathVertex1,\n"
"						sampleResult,\n"
"						&ray, &taskDirectLight->lightRadiance, &taskDirectLight->lightID\n"
"						MATERIALS_PARAM)\n"
"#endif\n"
"				;\n"
"				\n"
"				if (illuminated) {\n"
"					// Trace the shadow ray\n"
"					currentBSDF = &taskDirectLight->directLightBSDF;\n"
"					currentThroughput = &taskDirectLight->directLightThroughput;\n"
"					VSTORE3F(WHITE, &currentThroughput->r);\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"					// This is a bit tricky. I store the passThroughEvent in the BSDF\n"
"					// before of the initialization because it can be use during the\n"
"					// tracing of next path vertex ray.\n"
"					taskDirectLight->directLightBSDF.hitPoint.passThroughEvent = Rnd_FloatValue(&seed);\n"
"#endif\n"
"\n"
"					pathState = (pathState & HIGH_STATE_MASK) | DIRECT_LIGHT_TRACE_RAY;\n"
"				} else {\n"
"					// Move to the next path vertex\n"
"					pathState = (pathState & HIGH_STATE_MASK) | NEXT_VERTEX_GENERATE_RAY;\n"
"				}\n"
"			}\n"
"		}\n"
"\n"
"		//----------------------------------------------------------------------\n"
"		// Evaluation of the finite state machine.\n"
"		//\n"
"		// From: PATH_VERTEX_N | NEXT_VERTEX_GENERATE_RAY\n"
"		// To: PATH_VERTEX_1 | NEXT_VERTEX_GENERATE_RAY or (PATH_VERTEX_N | NEXT_VERTEX_TRACE_RAY[continue])\n"
"		//----------------------------------------------------------------------\n"
"\n"
"		if (pathState == (PATH_VERTEX_N | NEXT_VERTEX_GENERATE_RAY)) {\n"
"			//if (get_global_id(0) == 0)\n"
"			//	printf(\"(PATH_VERTEX_N | NEXT_VERTEX_GENERATE_RAY)) ==> Depth: %d  [pathState: %d|%d][currentThroughput: %f %f %f]\\n\",\n"
"			//			depthInfo.depth, pathState >> 16, pathState & LOW_STATE_MASK, currentThroughput->r, currentThroughput->g, currentThroughput->b);\n"
"\n"
"			// Sample the BSDF\n"
"			float3 sampledDir;\n"
"			float cosSampledDir;\n"
"			BSDFEvent event;\n"
"			const float3 bsdfSample = BSDF_Sample(&taskPathVertexN->bsdfPathVertexN,\n"
"				Rnd_FloatValue(&seed),\n"
"				Rnd_FloatValue(&seed),\n"
"				&sampledDir, &lastPdfW, &cosSampledDir, &event, ALL\n"
"				MATERIALS_PARAM);\n"
"\n"
"			PathDepthInfo_IncDepths(&depthInfo, event);\n"
"\n"
"			if (!Spectrum_IsBlack(bsdfSample)) {\n"
"				float3 throughput = VLOAD3F(&taskPathVertexN->throughputPathVertexN.r);\n"
"				throughput *= bsdfSample * (cosSampledDir / max(PARAM_PDF_CLAMP_VALUE, lastPdfW));\n"
"				VSTORE3F(throughput, &taskPathVertexN->throughputPathVertexN.r);\n"
"\n"
"				Ray_Init2_Private(&ray, VLOAD3F(&taskPathVertexN->bsdfPathVertexN.hitPoint.p.x), sampledDir);\n"
"\n"
"				lastBSDFEvent = event;\n"
"\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"				// This is a bit tricky. I store the passThroughEvent in the BSDF\n"
"				// before of the initialization because it can be use during the\n"
"				// tracing of next path vertex ray.\n"
"				taskPathVertexN->bsdfPathVertexN.hitPoint.passThroughEvent = Rnd_FloatValue(&seed);\n"
"#endif\n"
"				currentBSDF = &taskPathVertexN->bsdfPathVertexN;\n"
"				currentThroughput = &taskPathVertexN->throughputPathVertexN;\n"
"\n"
"				pathState = PATH_VERTEX_N | NEXT_VERTEX_TRACE_RAY;\n"
"			} else\n"
"				pathState = PATH_VERTEX_1 | NEXT_VERTEX_GENERATE_RAY;\n"
"		}\n"
"\n"
"		//----------------------------------------------------------------------\n"
"		// Evaluation of the finite state machine.\n"
"		//\n"
"		// From: PATH_VERTEX_1 | NEXT_VERTEX_GENERATE_RAY\n"
"		// To: BREAK or (PATH_VERTEX_N | NEXT_VERTEX_TRACE_RAY[continue])\n"
"		//----------------------------------------------------------------------\n"
"\n"
"		if (pathState == (PATH_VERTEX_1 | NEXT_VERTEX_GENERATE_RAY)) {\n"
"			//if (get_global_id(0) == 0)\n"
"			//	printf(\"(PATH_VERTEX_1 | NEXT_VERTEX_GENERATE_RAY)) ==> Depth: %d  [pathState: %d|%d][currentThroughput: %f %f %f]\\n\",\n"
"			//			depthInfo.depth, pathState >> 16, pathState & LOW_STATE_MASK, currentThroughput->r, currentThroughput->g, currentThroughput->b);\n"
"\n"
"			BSDFEvent vertex1SampleComponent = taskPathVertexN->vertex1SampleComponent;\n"
"			uint vertex1SampleIndex = taskPathVertexN->vertex1SampleIndex;\n"
"			const BSDFEvent materialEventTypes = BSDF_GetEventTypes(&task->bsdfPathVertex1\n"
"				MATERIALS_PARAM);\n"
"\n"
"			for (;;) {\n"
"				const int matSamplesCount = materialSamples[task->bsdfPathVertex1.materialIndex];\n"
"				const uint globalMatSamplesCount = ((vertex1SampleComponent == DIFFUSE) ? PARAM_DIFFUSE_SAMPLES :\n"
"					((vertex1SampleComponent == GLOSSY) ? PARAM_GLOSSY_SAMPLES :\n"
"						PARAM_SPECULAR_SAMPLES));\n"
"				const uint sampleCount = (matSamplesCount < 0) ? globalMatSamplesCount : (uint)matSamplesCount;\n"
"				const uint sampleCount2 = sampleCount * sampleCount;\n"
"\n"
"				if (!(materialEventTypes & vertex1SampleComponent) || (vertex1SampleIndex >= sampleCount2)) {\n"
"					// Move to next component\n"
"					if (vertex1SampleComponent == DIFFUSE)\n"
"						vertex1SampleComponent = GLOSSY;\n"
"					else if (vertex1SampleComponent == GLOSSY)\n"
"						vertex1SampleComponent = SPECULAR;\n"
"					else {\n"
"						// We have sampled all 3 components. Done.\n"
"						pathState = DONE;\n"
"						break;\n"
"					}\n"
"\n"
"					vertex1SampleIndex = 0;\n"
"					continue;\n"
"				}\n"
"\n"
"				// Sample the BSDF\n"
"				float3 sampledDir;\n"
"				float cosSampledDir;\n"
"				BSDFEvent event;\n"
"\n"
"				float u0, u1;\n"
"				SampleGrid(&seed, sampleCount,\n"
"					vertex1SampleIndex % sampleCount, vertex1SampleIndex / sampleCount,\n"
"					&u0, &u1);\n"
"\n"
"				// Now, I can increment vertex1SampleIndex\n"
"				++vertex1SampleIndex;\n"
"\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"				// This is a bit tricky. I store the passThroughEvent in the BSDF\n"
"				// before of the initialization because it can be use during the\n"
"				// tracing of next path vertex ray.\n"
"				task->bsdfPathVertex1.hitPoint.passThroughEvent = Rnd_FloatValue(&seed);\n"
"#endif\n"
"				const float3 bsdfSample = BSDF_Sample(&task->bsdfPathVertex1,\n"
"						u0,\n"
"						u1,\n"
"						&sampledDir, &lastPdfW, &cosSampledDir, &event,\n"
"						vertex1SampleComponent | REFLECT | TRANSMIT\n"
"						MATERIALS_PARAM);\n"
"\n"
"				PathDepthInfo_Init(&depthInfo, 0);\n"
"				PathDepthInfo_IncDepths(&depthInfo, event);\n"
"\n"
"				if (!Spectrum_IsBlack(bsdfSample)) {\n"
"					const float scaleFactor = 1.f / sampleCount2;\n"
"					float3 throughput = VLOAD3F(&task->throughputPathVertex1.r);\n"
"					throughput *= bsdfSample * (scaleFactor * cosSampledDir / max(PARAM_PDF_CLAMP_VALUE, lastPdfW));\n"
"					VSTORE3F(throughput, &taskPathVertexN->throughputPathVertexN.r);\n"
"\n"
"					Ray_Init2_Private(&ray, VLOAD3F(&task->bsdfPathVertex1.hitPoint.p.x), sampledDir);\n"
"\n"
"					pathBSDFEvent = event;\n"
"					lastBSDFEvent = event;\n"
"\n"
"#if defined(PARAM_HAS_PASSTHROUGH)\n"
"					// This is a bit tricky. I store the passThroughEvent in the BSDF\n"
"					// before of the initialization because it can be use during the\n"
"					// tracing of next path vertex ray.\n"
"					taskPathVertexN->bsdfPathVertexN.hitPoint.passThroughEvent = Rnd_FloatValue(&seed);\n"
"#endif\n"
"					currentBSDF = &taskPathVertexN->bsdfPathVertexN;\n"
"					currentThroughput = &taskPathVertexN->throughputPathVertexN;\n"
"\n"
"					pathState = PATH_VERTEX_N | NEXT_VERTEX_TRACE_RAY;\n"
"\n"
"					// Save vertex1SampleComponent and vertex1SampleIndex\n"
"					taskPathVertexN->vertex1SampleComponent = vertex1SampleComponent;\n"
"					taskPathVertexN->vertex1SampleIndex = vertex1SampleIndex;\n"
"					break;\n"
"				}\n"
"			}\n"
"		}\n"
"	}\n"
"\n"
"	//if (get_global_id(0) == 0) {\n"
"	//	printf(\"============================================================\\n\");\n"
"	//	printf(\"== End loop\\n\");\n"
"	//	printf(\"============================================================\\n\");\n"
"	//}\n"
"\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_RAYCOUNT)\n"
"	sampleResult->rayCount = tracedRaysCount;\n"
"#endif\n"
"\n"
"	// Radiance clamping\n"
"	SR_RadianceClamp(sampleResult);\n"
"\n"
"#if defined(PARAM_TILE_PROGRESSIVE_REFINEMENT)\n"
"	// Initialize Film radiance group pointer table\n"
"	__global float *filmRadianceGroup[PARAM_FILM_RADIANCE_GROUP_COUNT];\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_0)\n"
"		filmRadianceGroup[0] = filmRadianceGroup0;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_1)\n"
"		filmRadianceGroup[1] = filmRadianceGroup1;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_2)\n"
"		filmRadianceGroup[2] = filmRadianceGroup2;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_3)\n"
"		filmRadianceGroup[3] = filmRadianceGroup3;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_4)\n"
"		filmRadianceGroup[3] = filmRadianceGroup4;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_5)\n"
"		filmRadianceGroup[3] = filmRadianceGroup5;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_6)\n"
"		filmRadianceGroup[3] = filmRadianceGroup6;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_7)\n"
"		filmRadianceGroup[3] = filmRadianceGroup7;\n"
"#endif\n"
"\n"
"	Film_AddSample(samplePixelX, samplePixelY, sampleResult, 1.f\n"
"			FILM_PARAM);\n"
"#endif\n"
"\n"
"	taskStat->raysCount = tracedRaysCount;\n"
"\n"
"	// Save the seed\n"
"	task->seed.s1 = seed.s1;\n"
"	task->seed.s2 = seed.s2;\n"
"	task->seed.s3 = seed.s3;\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// MergePixelSamples\n"
"//------------------------------------------------------------------------------\n"
"\n"
"void SR_Accumulate(__global SampleResult *src, SampleResult *dst) {\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_0)\n"
"	dst->radiancePerPixelNormalized[0].r += src->radiancePerPixelNormalized[0].r;\n"
"	dst->radiancePerPixelNormalized[0].g += src->radiancePerPixelNormalized[0].g;\n"
"	dst->radiancePerPixelNormalized[0].b += src->radiancePerPixelNormalized[0].b;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_1)\n"
"	dst->radiancePerPixelNormalized[1].r += src->radiancePerPixelNormalized[1].r;\n"
"	dst->radiancePerPixelNormalized[1].g += src->radiancePerPixelNormalized[1].g;\n"
"	dst->radiancePerPixelNormalized[1].b += src->radiancePerPixelNormalized[1].b;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_2)\n"
"	dst->radiancePerPixelNormalized[2].r += src->radiancePerPixelNormalized[2].r;\n"
"	dst->radiancePerPixelNormalized[2].g += src->radiancePerPixelNormalized[2].g;\n"
"	dst->radiancePerPixelNormalized[2].b += src->radiancePerPixelNormalized[2].b;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_3)\n"
"	dst->radiancePerPixelNormalized[3].r += src->radiancePerPixelNormalized[3].r;\n"
"	dst->radiancePerPixelNormalized[3].g += src->radiancePerPixelNormalized[3].g;\n"
"	dst->radiancePerPixelNormalized[3].b += src->radiancePerPixelNormalized[3].b;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_4)\n"
"	dst->radiancePerPixelNormalized[4].r += src->radiancePerPixelNormalized[4].r;\n"
"	dst->radiancePerPixelNormalized[4].g += src->radiancePerPixelNormalized[4].g;\n"
"	dst->radiancePerPixelNormalized[4].b += src->radiancePerPixelNormalized[4].b;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_5)\n"
"	dst->radiancePerPixelNormalized[5].r += src->radiancePerPixelNormalized[5].r;\n"
"	dst->radiancePerPixelNormalized[5].g += src->radiancePerPixelNormalized[5].g;\n"
"	dst->radiancePerPixelNormalized[5].b += src->radiancePerPixelNormalized[5].b;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_6)\n"
"	dst->radiancePerPixelNormalized[6].r += src->radiancePerPixelNormalized[6].r;\n"
"	dst->radiancePerPixelNormalized[6].g += src->radiancePerPixelNormalized[6].g;\n"
"	dst->radiancePerPixelNormalized[6].b += src->radiancePerPixelNormalized[6].b;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_7)\n"
"	dst->radiancePerPixelNormalized[7].r += src->radiancePerPixelNormalized[7].r;\n"
"	dst->radiancePerPixelNormalized[7].g += src->radiancePerPixelNormalized[7].g;\n"
"	dst->radiancePerPixelNormalized[7].b += src->radiancePerPixelNormalized[7].b;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_ALPHA)\n"
"	dst->alpha += dst->alpha + src->alpha;\n"
"#endif\n"
"\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_DIFFUSE)\n"
"	dst->directDiffuse.r += src->directDiffuse.r;\n"
"	dst->directDiffuse.g += src->directDiffuse.g;\n"
"	dst->directDiffuse.b += src->directDiffuse.b;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_GLOSSY)\n"
"	dst->directGlossy.r += src->directGlossy.r;\n"
"	dst->directGlossy.g += src->directGlossy.g;\n"
"	dst->directGlossy.b += src->directGlossy.b;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_EMISSION)\n"
"	dst->emission.r += src->emission.r;\n"
"	dst->emission.g += src->emission.g;\n"
"	dst->emission.b += src->emission.b;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_DIFFUSE)\n"
"	dst->indirectDiffuse.r += src->indirectDiffuse.r;\n"
"	dst->indirectDiffuse.g += src->indirectDiffuse.g;\n"
"	dst->indirectDiffuse.b += src->indirectDiffuse.b;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_GLOSSY)\n"
"	dst->indirectGlossy.r += src->indirectGlossy.r;\n"
"	dst->indirectGlossy.g += src->indirectGlossy.g;\n"
"	dst->indirectGlossy.b += src->indirectGlossy.b;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SPECULAR)\n"
"	dst->indirectSpecular.r += src->indirectSpecular.r;\n"
"	dst->indirectSpecular.g += src->indirectSpecular.g;\n"
"	dst->indirectSpecular.b += src->indirectSpecular.b;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_SHADOW_MASK)\n"
"	dst->directShadowMask += src->directShadowMask;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SHADOW_MASK)\n"
"	dst->indirectShadowMask += src->indirectShadowMask;\n"
"#endif\n"
"\n"
"	bool depthWrite = true;\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DEPTH)\n"
"	const float srcDepthValue = src->depth;\n"
"	if (srcDepthValue <= dst->depth)\n"
"		dst->depth = srcDepthValue;\n"
"	else\n"
"		depthWrite = false;\n"
"#endif\n"
"	if (depthWrite) {\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_POSITION)\n"
"		dst->position = src->position;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_GEOMETRY_NORMAL)\n"
"		dst->geometryNormal = src->geometryNormal;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_SHADING_NORMAL)\n"
"		dst->shadingNormal = src->shadingNormal;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_MATERIAL_ID)\n"
"		// Note: MATERIAL_ID_MASK is calculated starting from materialID field\n"
"		dst->materialID = src->materialID;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_UV)\n"
"		dst->uv = src->uv;\n"
"#endif\n"
"	}\n"
"\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_RAYCOUNT)\n"
"	dst->rayCount += src->rayCount;\n"
"#endif\n"
"}\n"
"\n"
"void SR_Normalize(SampleResult *dst, const float k) {\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_0)\n"
"	dst->radiancePerPixelNormalized[0].r *= k;\n"
"	dst->radiancePerPixelNormalized[0].g *= k;\n"
"	dst->radiancePerPixelNormalized[0].b *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_1)\n"
"	dst->radiancePerPixelNormalized[1].r *= k;\n"
"	dst->radiancePerPixelNormalized[1].g *= k;\n"
"	dst->radiancePerPixelNormalized[1].b *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_2)\n"
"	dst->radiancePerPixelNormalized[2].r *= k;\n"
"	dst->radiancePerPixelNormalized[2].g *= k;\n"
"	dst->radiancePerPixelNormalized[2].b *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_3)\n"
"	dst->radiancePerPixelNormalized[3].r *= k;\n"
"	dst->radiancePerPixelNormalized[3].g *= k;\n"
"	dst->radiancePerPixelNormalized[3].b *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_4)\n"
"	dst->radiancePerPixelNormalized[4].r *= k;\n"
"	dst->radiancePerPixelNormalized[4].g *= k;\n"
"	dst->radiancePerPixelNormalized[4].b *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_5)\n"
"	dst->radiancePerPixelNormalized[5].r *= k;\n"
"	dst->radiancePerPixelNormalized[5].g *= k;\n"
"	dst->radiancePerPixelNormalized[5].b *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_6)\n"
"	dst->radiancePerPixelNormalized[6].r *= k;\n"
"	dst->radiancePerPixelNormalized[6].g *= k;\n"
"	dst->radiancePerPixelNormalized[6].b *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_7)\n"
"	dst->radiancePerPixelNormalized[7].r *= k;\n"
"	dst->radiancePerPixelNormalized[7].g *= k;\n"
"	dst->radiancePerPixelNormalized[7].b *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_ALPHA)\n"
"	dst->alpha *= k;\n"
"#endif\n"
"\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_DIFFUSE)\n"
"	dst->directDiffuse.r *= k;\n"
"	dst->directDiffuse.g *= k;\n"
"	dst->directDiffuse.b *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_GLOSSY)\n"
"	dst->directGlossy.r *= k;\n"
"	dst->directGlossy.g *= k;\n"
"	dst->directGlossy.b *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_EMISSION)\n"
"	dst->emission.r *= k;\n"
"	dst->emission.g *= k;\n"
"	dst->emission.b *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_DIFFUSE)\n"
"	dst->indirectDiffuse.r *= k;\n"
"	dst->indirectDiffuse.g *= k;\n"
"	dst->indirectDiffuse.b *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_GLOSSY)\n"
"	dst->indirectGlossy.r *= k;\n"
"	dst->indirectGlossy.g *= k;\n"
"	dst->indirectGlossy.b *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SPECULAR)\n"
"	dst->indirectSpecular.r *= k;\n"
"	dst->indirectSpecular.g *= k;\n"
"	dst->indirectSpecular.b *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_SHADOW_MASK)\n"
"	dst->directShadowMask *= k;\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SHADOW_MASK)\n"
"	dst->indirectShadowMask *= k;\n"
"#endif\n"
"}\n"
"\n"
"__kernel __attribute__((work_group_size_hint(64, 1, 1))) void MergePixelSamples(\n"
"		const uint tileStartX,\n"
"		const uint tileStartY,\n"
"		const uint engineFilmWidth, const uint engineFilmHeight,\n"
"		__global SampleResult *taskResults,\n"
"		// Film parameters\n"
"		const uint filmWidth, const uint filmHeight\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_0)\n"
"		, __global float *filmRadianceGroup0\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_1)\n"
"		, __global float *filmRadianceGroup1\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_2)\n"
"		, __global float *filmRadianceGroup2\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_3)\n"
"		, __global float *filmRadianceGroup3\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_4)\n"
"		, __global float *filmRadianceGroup4\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_5)\n"
"		, __global float *filmRadianceGroup5\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_6)\n"
"		, __global float *filmRadianceGroup6\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_7)\n"
"		, __global float *filmRadianceGroup7\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_ALPHA)\n"
"		, __global float *filmAlpha\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DEPTH)\n"
"		, __global float *filmDepth\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_POSITION)\n"
"		, __global float *filmPosition\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_GEOMETRY_NORMAL)\n"
"		, __global float *filmGeometryNormal\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_SHADING_NORMAL)\n"
"		, __global float *filmShadingNormal\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_MATERIAL_ID)\n"
"		, __global uint *filmMaterialID\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_DIFFUSE)\n"
"		, __global float *filmDirectDiffuse\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_GLOSSY)\n"
"		, __global float *filmDirectGlossy\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_EMISSION)\n"
"		, __global float *filmEmission\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_DIFFUSE)\n"
"		, __global float *filmIndirectDiffuse\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_GLOSSY)\n"
"		, __global float *filmIndirectGlossy\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SPECULAR)\n"
"		, __global float *filmIndirectSpecular\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_MATERIAL_ID_MASK)\n"
"		, __global float *filmMaterialIDMask\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_DIRECT_SHADOW_MASK)\n"
"		, __global float *filmDirectShadowMask\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_INDIRECT_SHADOW_MASK)\n"
"		, __global float *filmIndirectShadowMask\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_UV)\n"
"		, __global float *filmUV\n"
"#endif\n"
"#if defined(PARAM_FILM_CHANNELS_HAS_RAYCOUNT)\n"
"		, __global float *filmRayCount\n"
"#endif\n"
"		) {\n"
"	const size_t gid = get_global_id(0);\n"
"\n"
"	uint sampleX, sampleY;\n"
"	sampleX = gid % PARAM_TILE_SIZE;\n"
"	sampleY = gid / PARAM_TILE_SIZE;\n"
"\n"
"	if ((gid >= PARAM_TILE_SIZE * PARAM_TILE_SIZE) ||\n"
"			(tileStartX + sampleX >= engineFilmWidth) ||\n"
"			(tileStartY + sampleY >= engineFilmHeight))\n"
"		return;\n"
"\n"
"	__global SampleResult *sampleResult = &taskResults[gid * PARAM_AA_SAMPLES * PARAM_AA_SAMPLES];\n"
"\n"
"	//--------------------------------------------------------------------------\n"
"	// Initialize Film radiance group pointer table\n"
"	//--------------------------------------------------------------------------\n"
"\n"
"	__global float *filmRadianceGroup[PARAM_FILM_RADIANCE_GROUP_COUNT];\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_0)\n"
"	filmRadianceGroup[0] = filmRadianceGroup0;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_1)\n"
"	filmRadianceGroup[1] = filmRadianceGroup1;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_2)\n"
"	filmRadianceGroup[2] = filmRadianceGroup2;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_3)\n"
"	filmRadianceGroup[3] = filmRadianceGroup3;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_4)\n"
"	filmRadianceGroup[3] = filmRadianceGroup4;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_5)\n"
"	filmRadianceGroup[3] = filmRadianceGroup5;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_6)\n"
"	filmRadianceGroup[3] = filmRadianceGroup6;\n"
"#endif\n"
"#if defined(PARAM_FILM_RADIANCE_GROUP_7)\n"
"	filmRadianceGroup[3] = filmRadianceGroup7;\n"
"#endif\n"
"\n"
"	//--------------------------------------------------------------------------\n"
"	// Merge all samples\n"
"	//--------------------------------------------------------------------------\n"
"\n"
"	SampleResult result = sampleResult[0];\n"
"	for (uint i = 1; i < PARAM_AA_SAMPLES * PARAM_AA_SAMPLES; ++i)\n"
"		SR_Accumulate(&sampleResult[i], &result);\n"
"	SR_Normalize(&result, 1.f / (PARAM_AA_SAMPLES * PARAM_AA_SAMPLES));\n"
"\n"
"	// I have to save result in __global space in order to be able\n"
"	// to use Film_AddSample(). OpenCL can be so stupid some time...\n"
"	sampleResult[0] = result;\n"
"	Film_AddSample(sampleX, sampleY, &sampleResult[0], PARAM_AA_SAMPLES * PARAM_AA_SAMPLES\n"
"			FILM_PARAM);\n"
"}\n"
; } }
